{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/eftel/Documents/AngularLearn/learn-angular/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Inject, EventEmitter, Component, ChangeDetectionStrategy, Input, Output, Directive, HostListener, Host, NgModule } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\nimport * as i1 from '@angular/common';\nimport { CommonModule } from '@angular/common';\nfunction SwalPortalComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nconst swalProviderToken = new InjectionToken('@sweetalert2/ngx-sweetalert2#swalProvider');\nconst fireOnInitToken = new InjectionToken('@sweetalert2/ngx-sweetalert2#fireOnInit');\nconst dismissOnDestroyToken = new InjectionToken('@sweetalert2/ngx-sweetalert2#dismissOnDestroy');\nclass SweetAlert2LoaderService {\n  swalProvider;\n  swalPromiseCache;\n  // Using any because Angular metadata generator does not understand a pure TS type here\n  constructor(swalProvider) {\n    this.swalProvider = swalProvider;\n  }\n  get swal() {\n    if (!this.swalPromiseCache) {\n      this.preloadSweetAlertLibrary();\n    }\n    return this.swalPromiseCache;\n  }\n  preloadSweetAlertLibrary() {\n    if (this.swalPromiseCache) return;\n    const libPromise = isLoader(this.swalProvider) ? this.swalProvider() : Promise.resolve(this.swalProvider);\n    this.swalPromiseCache = libPromise.then(value => isDefaultExport(value) ? value : value.default);\n    function isLoader(value) {\n      return typeof value === 'function' && value.version === undefined;\n    }\n    function isDefaultExport(value) {\n      return typeof value === 'function';\n    }\n  }\n  static ɵfac = function SweetAlert2LoaderService_Factory(t) {\n    return new (t || SweetAlert2LoaderService)(i0.ɵɵinject(swalProviderToken));\n  };\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SweetAlert2LoaderService,\n    factory: SweetAlert2LoaderService.ɵfac\n  });\n}\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SweetAlert2LoaderService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [swalProviderToken]\n      }]\n    }];\n  }, null);\n})();\n\n/**\n * <swal> component. See the README.md for usage.\n *\n * It contains a bunch of @Inputs that have a perfect 1:1 mapping with SweetAlert2 options.\n * Their types are directly coming from SweetAlert2 types defintitions, meaning that ngx-sweetalert2 is tightly coupled\n * to SweetAlert2, but also is type-safe even if both libraries do not evolve in sync.\n *\n * (?) If you want to use an object that declares the SweetAlert2 options all at once rather than many @Inputs,\n *     take a look at [swalOptions], that lets you pass a full {@link SweetAlertOptions} object.\n *\n * (?) If you are reading the TypeScript source of this component, you may think that it's a lot of code.\n *     Be sure that a lot of this code is types and Angular boilerplate. Compiled and minified code is much smaller.\n *     If you are really concerned about performance and/or don't care about the API and its convenient integration\n *     with Angular (notably change detection and transclusion), you may totally use SweetAlert2 natively as well ;)\n *\n * /!\\ Some SweetAlert options aren't @Inputs but @Outputs: `willOpen`, `didOpen`, `didRender`, `willClose`, `didClose`\n *     and `didDestroy`.\n *     However, `preConfirm`, `preDeny` and `inputValidator` are still @Inputs because they are not event handlers,\n *     there can't be multiple listeners on them, and we need the values they can/must return.\n */\nclass SwalComponent {\n  sweetAlert2Loader;\n  moduleLevelFireOnInit;\n  moduleLevelDismissOnDestroy;\n  title;\n  titleText;\n  text;\n  html;\n  footer;\n  icon;\n  iconColor;\n  iconHtml;\n  backdrop;\n  toast;\n  target;\n  input;\n  width;\n  padding;\n  background;\n  position;\n  grow;\n  showClass;\n  hideClass;\n  customClass;\n  timer;\n  timerProgressBar;\n  heightAuto;\n  allowOutsideClick;\n  allowEscapeKey;\n  allowEnterKey;\n  stopKeydownPropagation;\n  keydownListenerCapture;\n  showConfirmButton;\n  showDenyButton;\n  showCancelButton;\n  confirmButtonText;\n  denyButtonText;\n  cancelButtonText;\n  confirmButtonColor;\n  denyButtonColor;\n  cancelButtonColor;\n  confirmButtonAriaLabel;\n  denyButtonAriaLabel;\n  cancelButtonAriaLabel;\n  buttonsStyling;\n  reverseButtons;\n  focusConfirm;\n  focusDeny;\n  focusCancel;\n  showCloseButton;\n  closeButtonHtml;\n  closeButtonAriaLabel;\n  loaderHtml;\n  showLoaderOnConfirm;\n  preConfirm;\n  preDeny;\n  imageUrl;\n  imageWidth;\n  imageHeight;\n  imageAlt;\n  inputLabel;\n  inputPlaceholder;\n  inputValue;\n  inputOptions;\n  inputAutoTrim;\n  inputAttributes;\n  inputValidator;\n  returnInputValueOnDeny;\n  validationMessage;\n  progressSteps;\n  currentProgressStep;\n  progressStepsDistance;\n  scrollbarPadding;\n  /**\n   * An object of SweetAlert2 native options, useful if:\n   *  - you don't want to use the @Inputs for practical/philosophical reasons ;\n   *  - there are missing @Inputs because ngx-sweetalert2 isn't up-to-date with SweetAlert2's latest changes.\n   *\n   * /!\\ Please note that setting this property does NOT erase what has been set before unless you specify the\n   *     previous properties you want to erase again.\n   *     Ie. setting { title: 'Title' } and then { text: 'Text' } will give { title: 'Title', text: 'Text' }.\n   *\n   * /!\\ Be aware that the options defined in this object will override the @Inputs of the same name.\n   */\n  set swalOptions(options) {\n    //=> Update properties\n    Object.assign(this, options);\n    //=> Mark changed properties as touched\n    const touchedKeys = Object.keys(options);\n    touchedKeys.forEach(this.markTouched);\n  }\n  /**\n   * Computes the options object that will get passed to SweetAlert2.\n   * Only the properties that have been set at least once on this component will be returned.\n   * Mostly for internal usage.\n   */\n  get swalOptions() {\n    //=> We will compute the options object based on the option keys that are known to have changed.\n    //   That avoids passing a gigantic object to SweetAlert2, making debugging easier and potentially\n    //   avoiding side effects.\n    return [...this.touchedProps].reduce((obj, key) => ({\n      ...obj,\n      [key]: this[key]\n    }), {});\n  }\n  /**\n   * Whether to fire the modal as soon as the <swal> component is created and initialized in the view.\n   * When left undefined (default), the value will be inherited from the module configuration, which is `false`.\n   *\n   * Example:\n   *     <swal *ngIf=\"error\" [title]=\"error.title\" [text]=\"error.text\" icon=\"error\" [swalFireOnInit]=\"true\"></swal>\n   */\n  swalFireOnInit;\n  /**\n   * Whether to dismiss the modal when the <swal> component is destroyed by Angular (for any reason) or not.\n   * When left undefined (default), the value will be inherited from the module configuration, which is `true`.\n   */\n  swalDismissOnDestroy;\n  set swalVisible(visible) {\n    visible ? this.fire() : this.close();\n  }\n  get swalVisible() {\n    return this.isCurrentlyShown;\n  }\n  /**\n   * Modal lifecycle hook. Synchronously runs before the modal is shown on screen.\n   */\n  willOpen = new EventEmitter();\n  /**\n   * Modal lifecycle hook. Synchronously runs before the modal is shown on screen.\n   */\n  didOpen = new EventEmitter();\n  /**\n   * Modal lifecycle hook. Synchronously runs after the popup DOM has been updated (ie. just before the modal is\n   * repainted on the screen).\n   * Typically, this will happen after `Swal.fire()` or `Swal.update()`.\n   * If you want to perform changes in the popup's DOM, that survive `Swal.update()`, prefer {@link didRender} over\n   * {@link willOpen}.\n   */\n  didRender = new EventEmitter();\n  /**\n   * Modal lifecycle hook. Synchronously runs when the popup closes by user interaction (and not due to another popup\n   * being fired).\n   */\n  willClose = new EventEmitter();\n  /**\n   * Modal lifecycle hook. Asynchronously runs after the popup has been disposed by user interaction (and not due to\n   * another popup being fired).\n   */\n  didClose = new EventEmitter();\n  /**\n   * Modal lifecycle hook. Synchronously runs after popup has been destroyed either by user interaction or by another\n   * popup.\n   * If you have cleanup operations that you need to reliably execute each time a modal is closed, prefer\n   * {@link didDestroy} over {@link didClose}.\n   */\n  didDestroy = new EventEmitter();\n  /**\n   * Emits when the user clicks \"Confirm\".\n   * The event value ($event) can be either:\n   *  - by default, just `true`,\n   *  - when using {@link input}, the input value,\n   *  - when using {@link preConfirm}, the return value of this function.\n   *\n   * Example:\n   *     <swal (confirm)=\"handleConfirm($event)\"></swal>\n   *\n   *     public handleConfirm(email: string): void {\n   *         // ... save user email\n   *     }\n   */\n  confirm = new EventEmitter();\n  /**\n   * Emits when the user clicks \"Deny\".\n   * This event bears no value.\n   * Use `(deny)` (along with {@link showDenyButton}) when you want a modal with three buttons (confirm, deny and\n   * cancel), and/or when you want to handle clear refusal in a separate way than simple dismissal.\n   *\n   * Example:\n   *     <swal (deny)=\"handleDeny()\"></swal>\n   *\n   *     public handleDeny(): void {\n   *     }\n   */\n  deny = new EventEmitter();\n  /**\n   * Emits when the user clicks \"Cancel\", or dismisses the modal by any other allowed way.\n   * The event value ($event) is a string that explains how the modal was dismissed. It is `undefined` when\n   * the modal was programmatically closed (through {@link close} for example).\n   *\n   * Example:\n   *     <swal (dismiss)=\"handleDismiss($event)\"></swal>\n   *\n   *     public handleDismiss(reason: DismissReason | undefined): void {\n   *         // reason can be 'cancel', 'overlay', 'close', 'timer' or undefined.\n   *         // ... do something\n   *     }\n   */\n  dismiss = new EventEmitter();\n  /**\n   * This Set retains the properties that have been changed from @Inputs, so we can know precisely\n   * what options we have to send to {@link Swal.fire}.\n   */\n  touchedProps = new Set();\n  /**\n   * A function of signature `(propName: string): void` that adds a given property name to the list of\n   * touched properties, ie. {@link touchedProps}.\n   */\n  markTouched = this.touchedProps.add.bind(this.touchedProps);\n  /**\n   * Is the SweetAlert2 modal represented by this component currently opened?\n   */\n  isCurrentlyShown = false;\n  constructor(sweetAlert2Loader, moduleLevelFireOnInit, moduleLevelDismissOnDestroy) {\n    this.sweetAlert2Loader = sweetAlert2Loader;\n    this.moduleLevelFireOnInit = moduleLevelFireOnInit;\n    this.moduleLevelDismissOnDestroy = moduleLevelDismissOnDestroy;\n  }\n  /**\n   * Angular lifecycle hook.\n   * Asks the SweetAlert2 loader service to preload the SweetAlert2 library, so it begins to be loaded only if there\n   * is a <swal> component somewhere, and is probably fully loaded when the modal has to be displayed,\n   * causing no delay.\n   */\n  ngOnInit() {\n    //=> Preload SweetAlert2 library in case this component is activated.\n    this.sweetAlert2Loader.preloadSweetAlertLibrary();\n  }\n  /**\n   * Angular lifecycle hook.\n   * Fires the modal, if the component or module is configured to do so.\n   */\n  ngAfterViewInit() {\n    const fireOnInit = this.swalFireOnInit === undefined ? this.moduleLevelFireOnInit : this.swalFireOnInit;\n    fireOnInit && this.fire();\n  }\n  /**\n   * Angular lifecycle hook.\n   * Updates the SweetAlert options, and if the modal is opened, asks SweetAlert to render it again.\n   */\n  ngOnChanges(changes) {\n    //=> For each changed @Input that matches a SweetAlert2 option, mark as touched so we can\n    //   send it with the next fire() or update() calls.\n    Object.keys(changes)\n    //=> If the filtering logic becomes more complex here, we can use Swal.isValidParameter\n    .filter(key => !key.startsWith('swal')).forEach(this.markTouched);\n    //=> Eventually trigger re-render if the modal is open.\n    void this.update();\n  }\n  /**\n   * Angular lifecycle hook.\n   * Closes the SweetAlert when the component is destroyed.\n   */\n  ngOnDestroy() {\n    //=> Release the modal if the component is destroyed and if that behaviour is not disabled.\n    const dismissOnDestroy = this.swalDismissOnDestroy === undefined ? this.moduleLevelDismissOnDestroy : this.swalDismissOnDestroy;\n    dismissOnDestroy && this.close();\n  }\n  /**\n   * Shows the SweetAlert.\n   *\n   * Returns the SweetAlert2 promise for convenience and use in code behind templates.\n   * Otherwise, (confirm)=\"myHandler($event)\" and (dismiss)=\"myHandler($event)\" can be used in templates.\n   */\n  fire() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const swal = yield _this.sweetAlert2Loader.swal;\n      const userOptions = _this.swalOptions;\n      //=> Build the SweetAlert2 options\n      const options = {\n        //=> Merge with calculated options set for that specific swal\n        ...userOptions,\n        //=> Handle modal lifecycle events\n        willOpen: composeHook(userOptions.willOpen, modalElement => {\n          _this.willOpen.emit({\n            modalElement\n          });\n        }),\n        didOpen: composeHook(userOptions.didOpen, modalElement => {\n          _this.isCurrentlyShown = true;\n          _this.didOpen.emit({\n            modalElement\n          });\n        }),\n        didRender: composeHook(userOptions.didRender, modalElement => {\n          _this.didRender.emit({\n            modalElement\n          });\n        }),\n        willClose: composeHook(userOptions.willClose, modalElement => {\n          _this.isCurrentlyShown = false;\n          _this.willClose.emit({\n            modalElement\n          });\n        }),\n        didClose: composeHook(userOptions.didClose, () => {\n          _this.didClose.emit();\n        }),\n        didDestroy: composeHook(userOptions.didDestroy, () => {\n          _this.didDestroy.emit();\n        })\n      };\n      //=> Show the Swal! And wait for confirmation or dimissal.\n      const result = yield swal.fire(options);\n      //=> Emit on (confirm), (deny) or (dismiss)\n      switch (true) {\n        case result.isConfirmed:\n          _this.confirm.emit(result.value);\n          break;\n        case result.isDenied:\n          _this.deny.emit();\n          break;\n        case result.isDismissed:\n          _this.dismiss.emit(result.dismiss);\n          break;\n      }\n      return result;\n      function composeHook(userHook, libHook) {\n        return (...args) => (libHook(...args), userHook?.(...args));\n      }\n    })();\n  }\n  /**\n   * Closes the modal, if opened.\n   *\n   * @param result The value that the modal will resolve with, triggering either (confirm), (deny) or (dismiss).\n   *               If the argument is not passed, it is (dismiss) that will emit an `undefined` reason.\n   *               {@see Swal.close}.\n   */\n  close(result) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this2.isCurrentlyShown) return;\n      const swal = yield _this2.sweetAlert2Loader.swal;\n      swal.close(result);\n    })();\n  }\n  /**\n   * Updates SweetAlert2 options while the modal is opened, causing the modal to re-render.\n   * If the modal is not opened, the component options will simply be updated and that's it.\n   *\n   * /!\\ Please note that not all SweetAlert2 options are updatable while the modal is opened.\n   *\n   * @param options\n   */\n  update(options) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      if (options) {\n        _this3.swalOptions = options;\n      }\n      if (!_this3.isCurrentlyShown) return;\n      const swal = yield _this3.sweetAlert2Loader.swal;\n      const allOptions = _this3.swalOptions;\n      const updatableOptions = Object.keys(allOptions).filter(swal.isUpdatableParameter).reduce((obj, key) => ({\n        ...obj,\n        [key]: allOptions[key]\n      }), {});\n      swal.update(updatableOptions);\n    })();\n  }\n  static ɵfac = function SwalComponent_Factory(t) {\n    return new (t || SwalComponent)(i0.ɵɵdirectiveInject(SweetAlert2LoaderService), i0.ɵɵdirectiveInject(fireOnInitToken), i0.ɵɵdirectiveInject(dismissOnDestroyToken));\n  };\n  static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: SwalComponent,\n    selectors: [[\"swal\"]],\n    inputs: {\n      title: \"title\",\n      titleText: \"titleText\",\n      text: \"text\",\n      html: \"html\",\n      footer: \"footer\",\n      icon: \"icon\",\n      iconColor: \"iconColor\",\n      iconHtml: \"iconHtml\",\n      backdrop: \"backdrop\",\n      toast: \"toast\",\n      target: \"target\",\n      input: \"input\",\n      width: \"width\",\n      padding: \"padding\",\n      background: \"background\",\n      position: \"position\",\n      grow: \"grow\",\n      showClass: \"showClass\",\n      hideClass: \"hideClass\",\n      customClass: \"customClass\",\n      timer: \"timer\",\n      timerProgressBar: \"timerProgressBar\",\n      heightAuto: \"heightAuto\",\n      allowOutsideClick: \"allowOutsideClick\",\n      allowEscapeKey: \"allowEscapeKey\",\n      allowEnterKey: \"allowEnterKey\",\n      stopKeydownPropagation: \"stopKeydownPropagation\",\n      keydownListenerCapture: \"keydownListenerCapture\",\n      showConfirmButton: \"showConfirmButton\",\n      showDenyButton: \"showDenyButton\",\n      showCancelButton: \"showCancelButton\",\n      confirmButtonText: \"confirmButtonText\",\n      denyButtonText: \"denyButtonText\",\n      cancelButtonText: \"cancelButtonText\",\n      confirmButtonColor: \"confirmButtonColor\",\n      denyButtonColor: \"denyButtonColor\",\n      cancelButtonColor: \"cancelButtonColor\",\n      confirmButtonAriaLabel: \"confirmButtonAriaLabel\",\n      denyButtonAriaLabel: \"denyButtonAriaLabel\",\n      cancelButtonAriaLabel: \"cancelButtonAriaLabel\",\n      buttonsStyling: \"buttonsStyling\",\n      reverseButtons: \"reverseButtons\",\n      focusConfirm: \"focusConfirm\",\n      focusDeny: \"focusDeny\",\n      focusCancel: \"focusCancel\",\n      showCloseButton: \"showCloseButton\",\n      closeButtonHtml: \"closeButtonHtml\",\n      closeButtonAriaLabel: \"closeButtonAriaLabel\",\n      loaderHtml: \"loaderHtml\",\n      showLoaderOnConfirm: \"showLoaderOnConfirm\",\n      preConfirm: \"preConfirm\",\n      preDeny: \"preDeny\",\n      imageUrl: \"imageUrl\",\n      imageWidth: \"imageWidth\",\n      imageHeight: \"imageHeight\",\n      imageAlt: \"imageAlt\",\n      inputLabel: \"inputLabel\",\n      inputPlaceholder: \"inputPlaceholder\",\n      inputValue: \"inputValue\",\n      inputOptions: \"inputOptions\",\n      inputAutoTrim: \"inputAutoTrim\",\n      inputAttributes: \"inputAttributes\",\n      inputValidator: \"inputValidator\",\n      returnInputValueOnDeny: \"returnInputValueOnDeny\",\n      validationMessage: \"validationMessage\",\n      progressSteps: \"progressSteps\",\n      currentProgressStep: \"currentProgressStep\",\n      progressStepsDistance: \"progressStepsDistance\",\n      scrollbarPadding: \"scrollbarPadding\",\n      swalOptions: \"swalOptions\",\n      swalFireOnInit: \"swalFireOnInit\",\n      swalDismissOnDestroy: \"swalDismissOnDestroy\",\n      swalVisible: \"swalVisible\"\n    },\n    outputs: {\n      willOpen: \"willOpen\",\n      didOpen: \"didOpen\",\n      didRender: \"didRender\",\n      willClose: \"willClose\",\n      didClose: \"didClose\",\n      didDestroy: \"didDestroy\",\n      confirm: \"confirm\",\n      deny: \"deny\",\n      dismiss: \"dismiss\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 0,\n    vars: 0,\n    template: function SwalComponent_Template(rf, ctx) {},\n    encapsulation: 2,\n    changeDetection: 0\n  });\n}\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SwalComponent, [{\n    type: Component,\n    args: [{\n      selector: 'swal',\n      template: '',\n      changeDetection: ChangeDetectionStrategy.OnPush\n    }]\n  }], function () {\n    return [{\n      type: SweetAlert2LoaderService\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [fireOnInitToken]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [dismissOnDestroyToken]\n      }]\n    }];\n  }, {\n    title: [{\n      type: Input\n    }],\n    titleText: [{\n      type: Input\n    }],\n    text: [{\n      type: Input\n    }],\n    html: [{\n      type: Input\n    }],\n    footer: [{\n      type: Input\n    }],\n    icon: [{\n      type: Input\n    }],\n    iconColor: [{\n      type: Input\n    }],\n    iconHtml: [{\n      type: Input\n    }],\n    backdrop: [{\n      type: Input\n    }],\n    toast: [{\n      type: Input\n    }],\n    target: [{\n      type: Input\n    }],\n    input: [{\n      type: Input\n    }],\n    width: [{\n      type: Input\n    }],\n    padding: [{\n      type: Input\n    }],\n    background: [{\n      type: Input\n    }],\n    position: [{\n      type: Input\n    }],\n    grow: [{\n      type: Input\n    }],\n    showClass: [{\n      type: Input\n    }],\n    hideClass: [{\n      type: Input\n    }],\n    customClass: [{\n      type: Input\n    }],\n    timer: [{\n      type: Input\n    }],\n    timerProgressBar: [{\n      type: Input\n    }],\n    heightAuto: [{\n      type: Input\n    }],\n    allowOutsideClick: [{\n      type: Input\n    }],\n    allowEscapeKey: [{\n      type: Input\n    }],\n    allowEnterKey: [{\n      type: Input\n    }],\n    stopKeydownPropagation: [{\n      type: Input\n    }],\n    keydownListenerCapture: [{\n      type: Input\n    }],\n    showConfirmButton: [{\n      type: Input\n    }],\n    showDenyButton: [{\n      type: Input\n    }],\n    showCancelButton: [{\n      type: Input\n    }],\n    confirmButtonText: [{\n      type: Input\n    }],\n    denyButtonText: [{\n      type: Input\n    }],\n    cancelButtonText: [{\n      type: Input\n    }],\n    confirmButtonColor: [{\n      type: Input\n    }],\n    denyButtonColor: [{\n      type: Input\n    }],\n    cancelButtonColor: [{\n      type: Input\n    }],\n    confirmButtonAriaLabel: [{\n      type: Input\n    }],\n    denyButtonAriaLabel: [{\n      type: Input\n    }],\n    cancelButtonAriaLabel: [{\n      type: Input\n    }],\n    buttonsStyling: [{\n      type: Input\n    }],\n    reverseButtons: [{\n      type: Input\n    }],\n    focusConfirm: [{\n      type: Input\n    }],\n    focusDeny: [{\n      type: Input\n    }],\n    focusCancel: [{\n      type: Input\n    }],\n    showCloseButton: [{\n      type: Input\n    }],\n    closeButtonHtml: [{\n      type: Input\n    }],\n    closeButtonAriaLabel: [{\n      type: Input\n    }],\n    loaderHtml: [{\n      type: Input\n    }],\n    showLoaderOnConfirm: [{\n      type: Input\n    }],\n    preConfirm: [{\n      type: Input\n    }],\n    preDeny: [{\n      type: Input\n    }],\n    imageUrl: [{\n      type: Input\n    }],\n    imageWidth: [{\n      type: Input\n    }],\n    imageHeight: [{\n      type: Input\n    }],\n    imageAlt: [{\n      type: Input\n    }],\n    inputLabel: [{\n      type: Input\n    }],\n    inputPlaceholder: [{\n      type: Input\n    }],\n    inputValue: [{\n      type: Input\n    }],\n    inputOptions: [{\n      type: Input\n    }],\n    inputAutoTrim: [{\n      type: Input\n    }],\n    inputAttributes: [{\n      type: Input\n    }],\n    inputValidator: [{\n      type: Input\n    }],\n    returnInputValueOnDeny: [{\n      type: Input\n    }],\n    validationMessage: [{\n      type: Input\n    }],\n    progressSteps: [{\n      type: Input\n    }],\n    currentProgressStep: [{\n      type: Input\n    }],\n    progressStepsDistance: [{\n      type: Input\n    }],\n    scrollbarPadding: [{\n      type: Input\n    }],\n    swalOptions: [{\n      type: Input\n    }],\n    swalFireOnInit: [{\n      type: Input\n    }],\n    swalDismissOnDestroy: [{\n      type: Input\n    }],\n    swalVisible: [{\n      type: Input\n    }],\n    willOpen: [{\n      type: Output\n    }],\n    didOpen: [{\n      type: Output\n    }],\n    didRender: [{\n      type: Output\n    }],\n    willClose: [{\n      type: Output\n    }],\n    didClose: [{\n      type: Output\n    }],\n    didDestroy: [{\n      type: Output\n    }],\n    confirm: [{\n      type: Output\n    }],\n    deny: [{\n      type: Output\n    }],\n    dismiss: [{\n      type: Output\n    }]\n  });\n})();\n\n/**\n * [swal] directive. It takes a value that defines the SweetAlert and can be of three types:\n *\n * 1) A simple array of two or three strings defining [title, text, icon] - the icon being optional, ex:\n *\n *    <button [swal]=\"['Title', 'Text']\">Click me</button>\n *\n * 2) A native SweetAlert2 options object, ex:\n *\n *    <button [swal]=\"{ title: 'Title', text: 'Text' }\">Click me</button>\n *\n * 3) A reference to an existing SwalComponent instance for more advanced uses, ex:\n *\n *    <button [swal]=\"mySwal\">Click me</button>\n *    <swal #mySwal title=\"Title\" text=\"Text\"></swal>\n */\nclass SwalDirective {\n  viewContainerRef;\n  resolver;\n  /**\n   * SweetAlert2 options or a SwalComponent instance.\n   * See the class doc block for more informations.\n   */\n  set swal(options) {\n    if (options instanceof SwalComponent) {\n      this.swalInstance = options;\n    } else if (isArrayOptions(options)) {\n      this.swalOptions = {};\n      [this.swalOptions.title, this.swalOptions.text, this.swalOptions.icon] = options;\n    } else {\n      this.swalOptions = options;\n    }\n    function isArrayOptions(value) {\n      return Array.isArray(options);\n    }\n  }\n  /**\n   * Emits when the user clicks \"Confirm\".\n   * The event value ($event) can be either:\n   *  - by default, just `true`,\n   *  - when using {@link input}, the input value,\n   *  - when using {@link preConfirm}, the return value of this function.\n   *\n   * Example:\n   *     <swal (confirm)=\"handleConfirm($event)\"></swal>\n   *\n   *     public handleConfirm(email: string): void {\n   *         // ... save user email\n   *     }\n   */\n  confirm = new EventEmitter();\n  /**\n   * Emits when the user clicks \"Deny\".\n   * This event bears no value.\n   * Use `(deny)` (along with {@link showDenyButton}) when you want a modal with three buttons (confirm, deny and\n   * cancel), and/or when you want to handle clear refusal in a separate way than simple dismissal.\n   *\n   * Example:\n   *     <swal (deny)=\"handleDeny()\"></swal>\n   *\n   *     public handleDeny(): void {\n   *     }\n   */\n  deny = new EventEmitter();\n  /**\n   * Emits when the user clicks \"Cancel\", or dismisses the modal by any other allowed way.\n   * The event value ($event) is a string that explains how the modal was dismissed. It is `undefined` when\n   * the modal was programmatically closed (through {@link dismiss} for example).\n   *\n   * Example:\n   *     <swal (dismiss)=\"handleDismiss($event)\"></swal>\n   *\n   *     public handleDismiss(reason: DismissReason | undefined): void {\n   *         // reason can be 'cancel', 'overlay', 'close', 'timer' or undefined.\n   *         // ... do something\n   *     }\n   */\n  dismiss = new EventEmitter();\n  /**\n   * When the user does not provides a SwalComponent instance, we create it on-the-fly and assign the plain-object\n   * options to it.\n   * This fields keeps a reference to the dynamically-created <swal>, to destroy it along this directive instance.\n   */\n  swalRef;\n  /**\n   * An instance of the <swal> component that this directive controls.\n   * Could be an instance passed by the user, otherwise it's the instance we've dynamically created.\n   */\n  swalInstance;\n  /**\n   * Holds the native SweetAlert2 options.\n   * Empty when the user passed an existing SwalComponent instance.\n   */\n  swalOptions;\n  constructor(viewContainerRef, resolver) {\n    this.viewContainerRef = viewContainerRef;\n    this.resolver = resolver;\n  }\n  /**\n   * OnInit lifecycle handler.\n   * Creates a SwalComponent instance if the user didn't provided one and binds on that component (confirm),\n   * (deny) and (dismiss) outputs to reemit on the directive.\n   */\n  ngOnInit() {\n    if (!this.swalInstance) {\n      const factory = this.resolver.resolveComponentFactory(SwalComponent);\n      this.swalRef = this.viewContainerRef.createComponent(factory);\n      this.swalInstance = this.swalRef.instance;\n    }\n  }\n  /**\n   * OnDestroy lifecycle handler.\n   * Destroys the dynamically-created SwalComponent.\n   */\n  ngOnDestroy() {\n    if (this.swalRef) {\n      this.swalRef.destroy();\n    }\n  }\n  /**\n   * Click handler.\n   * The directive listens for onclick events on its host element.\n   * When this happens, it shows the <swal> attached to this directive.\n   */\n  onClick(event) {\n    event.preventDefault();\n    event.stopImmediatePropagation();\n    event.stopPropagation();\n    if (!this.swalInstance) return;\n    if (this.swalOptions) {\n      this.swalInstance.swalOptions = this.swalOptions;\n    }\n    const swalClosed = new Subject();\n    this.swalInstance.confirm.asObservable().pipe(takeUntil(swalClosed)).subscribe(v => this.confirm.emit(v));\n    this.swalInstance.deny.asObservable().pipe(takeUntil(swalClosed)).subscribe(v => this.deny.emit(v));\n    this.swalInstance.dismiss.asObservable().pipe(takeUntil(swalClosed)).subscribe(v => this.dismiss.emit(v));\n    this.swalInstance.fire().then(() => swalClosed.next());\n  }\n  static ɵfac = function SwalDirective_Factory(t) {\n    return new (t || SwalDirective)(i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.ComponentFactoryResolver));\n  };\n  static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: SwalDirective,\n    selectors: [[\"\", \"swal\", \"\"]],\n    hostBindings: function SwalDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function SwalDirective_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        });\n      }\n    },\n    inputs: {\n      swal: \"swal\"\n    },\n    outputs: {\n      confirm: \"confirm\",\n      deny: \"deny\",\n      dismiss: \"dismiss\"\n    }\n  });\n}\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SwalDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[swal]'\n    }]\n  }], function () {\n    return [{\n      type: i0.ViewContainerRef\n    }, {\n      type: i0.ComponentFactoryResolver\n    }];\n  }, {\n    swal: [{\n      type: Input\n    }],\n    confirm: [{\n      type: Output\n    }],\n    deny: [{\n      type: Output\n    }],\n    dismiss: [{\n      type: Output\n    }],\n    onClick: [{\n      type: HostListener,\n      args: ['click', ['$event']]\n    }]\n  });\n})();\n\n/**\n * @internal\n * Holds a consumer's Angular template and displays it on a Sweet Alert.\n * See SwalPortalDirective for info about the covered feature.\n */\nclass SwalPortalComponent {\n  template = null;\n  static ɵfac = function SwalPortalComponent_Factory(t) {\n    return new (t || SwalPortalComponent)();\n  };\n  static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: SwalPortalComponent,\n    selectors: [[\"swal-portal\"]],\n    inputs: {\n      template: \"template\"\n    },\n    decls: 1,\n    vars: 1,\n    consts: [[4, \"ngTemplateOutlet\"]],\n    template: function SwalPortalComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, SwalPortalComponent_ng_container_0_Template, 1, 0, \"ng-container\", 0);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.template);\n      }\n    },\n    dependencies: [i1.NgTemplateOutlet],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n}\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SwalPortalComponent, [{\n    type: Component,\n    args: [{\n      selector: 'swal-portal',\n      template: '<ng-container *ngTemplateOutlet=\"template\"></ng-container>',\n      changeDetection: ChangeDetectionStrategy.OnPush\n    }]\n  }], null, {\n    template: [{\n      type: Input\n    }]\n  });\n})();\n\n/**\n * Represents an object of targets for <swal> portals (use with *swalPortal directive).\n * We must use thunks to access the Swal.* functions listed below, because they get created after the first modal is\n * shown, so this object lets us reference those functions safely and in a statically-typed manner.\n */\nclass SwalPortalTargets {\n  /**\n   * Targets the modal close button block contents.\n   */\n  closeButton = {\n    element: swal => swal.getCloseButton(),\n    options: {\n      showCloseButton: true\n    }\n  };\n  /**\n   * Targets the modal title block contents.\n   */\n  title = {\n    element: swal => swal.getTitle(),\n    // Empty text that will never be shown but necessary so SweetAlert2 makes the div visible.\n    options: {\n      title: ' '\n    }\n  };\n  /**\n   * Targets the modal text block contents (that is another block inside the first content block, so you can still\n   * use other modal features like Swal inputs, that are situated inside that parent content block).\n   */\n  content = {\n    element: swal => swal.getHtmlContainer(),\n    // Empty text that will never be shown but necessary so SweetAlert2 makes the div visible.\n    options: {\n      text: ' '\n    }\n  };\n  /**\n   * Targets the actions block contents, where are the confirm and cancel buttons in a normal time.\n   * /!\\ WARNING: using this target destroys some of the native SweetAlert2 modal's DOM, therefore, if you use this\n   *     target, do not update the modal via <swal> @Inputs while the modal is open, or you'll get an error.\n   *     We could workaround that inconvenient inside this integration, but that'd be detrimental to memory and\n   *     performance of everyone, for a relatively rare use case.\n   */\n  actions = {\n    element: swal => swal.getActions(),\n    // The button will never exist, but SweetAlert2 shows the actions block only if there is at least one button.\n    options: {\n      showConfirmButton: true\n    }\n  };\n  /**\n   * Targets the confirm button contents, replacing the text inside it (not the button itself)\n   */\n  confirmButton = {\n    element: swal => swal.getConfirmButton(),\n    options: {\n      showConfirmButton: true\n    }\n  };\n  /**\n   * Targets the deny button contents, replacing the text inside it (not the button itself)\n   */\n  denyButton = {\n    element: swal => swal.getDenyButton(),\n    options: {\n      showDenyButton: true\n    }\n  };\n  /**\n   * Targets the cancel button contents, replacing the text inside it (not the button itself)\n   */\n  cancelButton = {\n    element: swal => swal.getCancelButton(),\n    options: {\n      showCancelButton: true\n    }\n  };\n  /**\n   * Targets the modal footer contents.\n   */\n  footer = {\n    element: swal => swal.getFooter(),\n    // Empty text that will never be shown but necessary so SweetAlert2 makes the div visible.\n    options: {\n      footer: ' '\n    }\n  };\n  static ɵfac = function SwalPortalTargets_Factory(t) {\n    return new (t || SwalPortalTargets)();\n  };\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SwalPortalTargets,\n    factory: SwalPortalTargets.ɵfac,\n    providedIn: 'root'\n  });\n}\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SwalPortalTargets, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\n\n/**\n * A structural directive that lets you use Angular templates inside of SweetAlerts.\n * There are different targetable zones provided by {@link SwalPortalTargets}: title, content, confirmButton, etc, but\n * you can also make your own target by implementing {@link SwalPortalTarget} and giving it to this directive.\n * The default target is the alert text content zone.\n *\n * Usage in your component's TypeScript (if you use another target than {@link SwalPortalTargets.content}):\n *\n *     @Component({ ... })\n *     export class MyComponent {\n *         public constructor(public readonly swalTargets: SwalPortalTargets) {\n *         }\n *     }\n *\n * Usage in the template:\n *\n *     <swal title=\"Fill the form\" (confirm)=\"confirmHandler()\">\n *         <!-- This form will be displayed as the alert main content\n *              Targets the alert's main content zone by default -->\n *         <form *swalPortal [formControl]=\"myForm\">\n *             ...\n *         </form>\n *\n *         <!-- This targets the confirm button's inner content\n *              Notice the usage of ng-container to avoid creating an useless DOM element inside the button -->\n *         <ng-container *swalPortal=\"swalTargets.confirmButton\">\n *              Send ({{ secondsLeft }} seconds left)\n *         </ng-container>\n *     <swal>\n */\nclass SwalPortalDirective {\n  resolver;\n  injector;\n  app;\n  templateRef;\n  sweetAlert2Loader;\n  swalTargets;\n  swalComponent;\n  /**\n   * Takes a portal target or nothing (then it will target the text content zone by default).\n   *\n   * See the {@link SwalPortalTargets} service to see the available targets.\n   * See the class doc block for more informations.\n   */\n  target;\n  /**\n   * Holds the component reference of the controlled SwalPortalComponent to destroy it when no longer needed.\n   */\n  portalComponentRef;\n  destroyed = new Subject();\n  constructor(resolver, injector, app, templateRef, sweetAlert2Loader, swalTargets, swalComponent) {\n    this.resolver = resolver;\n    this.injector = injector;\n    this.app = app;\n    this.templateRef = templateRef;\n    this.sweetAlert2Loader = sweetAlert2Loader;\n    this.swalTargets = swalTargets;\n    this.swalComponent = swalComponent;\n  }\n  /**\n   * Subscribes to the the SweetAlert appearance/disappearance events to create/destroy the SwalPortalComponent\n   * that will receive the consumer's template.\n   */\n  ngOnInit() {\n    // Can't be set in a default property value, if the customer lets *swalPortal empty, the value we get is undef.\n    this.target = this.target || this.swalTargets.content;\n    //=> Apply the options provided by the target definition\n    void this.swalComponent.update(this.target.options);\n    //=> Subscribe to a few hooks frm the parent SwalComponent.\n    this.swalComponent.didRender.pipe(takeUntil(this.destroyed)).subscribe(this.didRenderHook.bind(this));\n    this.swalComponent.willOpen.pipe(takeUntil(this.destroyed)).subscribe(this.willOpenHook.bind(this));\n    this.swalComponent.didDestroy.pipe(takeUntil(this.destroyed)).subscribe(this.didDestroyHook.bind(this));\n  }\n  /**\n   * Signal any {@link destroyed} consumer that this is over, so they can unsubscribe from the\n   * parent SwalComponent events.\n   */\n  ngOnDestroy() {\n    this.destroyed.next();\n  }\n  /**\n   * This didRender hook runs 1..n times (per modal instance), just before the modal is shown (and also before the\n   * {@link willOpenHook}), or after Swal.update() is called.\n   * This is a good place to render, or re-render, our portal contents.\n   */\n  didRenderHook() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      //=> Ensure the portal component is created\n      if (!_this4.portalComponentRef) {\n        _this4.portalComponentRef = _this4.createPortalComponent();\n      }\n      //=> SweetAlert2 created the modal or just erased all of our content, so we need to install/reinstall it.\n      // Swal.update() is synchronous, this observable too, and mountComponentOnTarget too (the promise inside\n      // this function is already resolved at this point), so the whole process of re-rendering and re-mounting\n      // the portal component is fully synchronous, causing no blinks in the modal contents.\n      const swal = yield _this4.sweetAlert2Loader.swal;\n      //=> Find target element\n      const targetEl = _this4.target.element(swal);\n      if (!targetEl) return;\n      //=> Replace target's contents with our component\n      // https://jsperf.com/innerhtml-vs-removechild/15\n      while (targetEl.firstChild) {\n        targetEl.removeChild(targetEl.firstChild);\n      }\n      targetEl.appendChild(_this4.portalComponentRef.location.nativeElement);\n    })();\n  }\n  /**\n   * This willOpen hook runs once (per modal instance), just before the modal is shown on the screen.\n   * This is a good place to declare our detached view to the Angular app.\n   */\n  willOpenHook() {\n    if (!this.portalComponentRef) return;\n    //=> Make the Angular app aware of that detached view so rendering and change detection can happen\n    this.app.attachView(this.portalComponentRef.hostView);\n  }\n  /**\n   * This didDestroy hook runs once (per modal instance), just after the modal closing animation terminated.\n   * This is a good place to detach and destroy our content, that is not visible anymore.\n   */\n  didDestroyHook() {\n    if (!this.portalComponentRef) return;\n    //=> Detach the portal component from the app and destroy it\n    this.app.detachView(this.portalComponentRef.hostView);\n    this.portalComponentRef.destroy();\n    this.portalComponentRef = void 0;\n  }\n  /**\n   * Creates the {@link SwalPortalComponent} and gives it the customer's template ref.\n   */\n  createPortalComponent() {\n    //=> Create the SwalPortalComponent that will hold our content\n    const factory = this.resolver.resolveComponentFactory(SwalPortalComponent);\n    // Yes, we do not use the third argument that would directly use the target as the component's view\n    // (unfortunately, because that would give a cleaner DOM and would avoid dirty and direct DOM manipulations)\n    // That's because we want to keep our component safe from SweetAlert2's operations on the DOM, and to be\n    // able to restore it at any moment, ie. after the modal has been re-rendered.\n    const componentRef = factory.create(this.injector, []);\n    //=> Apply the consumer's template on the component\n    componentRef.instance.template = this.templateRef;\n    return componentRef;\n  }\n  static ɵfac = function SwalPortalDirective_Factory(t) {\n    return new (t || SwalPortalDirective)(i0.ɵɵdirectiveInject(i0.ComponentFactoryResolver), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.ApplicationRef), i0.ɵɵdirectiveInject(i0.TemplateRef), i0.ɵɵdirectiveInject(SweetAlert2LoaderService), i0.ɵɵdirectiveInject(SwalPortalTargets), i0.ɵɵdirectiveInject(SwalComponent, 1));\n  };\n  static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: SwalPortalDirective,\n    selectors: [[\"\", \"swalPortal\", \"\"]],\n    inputs: {\n      target: [\"swalPortal\", \"target\"]\n    }\n  });\n}\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SwalPortalDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[swalPortal]'\n    }]\n  }], function () {\n    return [{\n      type: i0.ComponentFactoryResolver\n    }, {\n      type: i0.Injector\n    }, {\n      type: i0.ApplicationRef\n    }, {\n      type: i0.TemplateRef\n    }, {\n      type: SweetAlert2LoaderService\n    }, {\n      type: SwalPortalTargets\n    }, {\n      type: SwalComponent,\n      decorators: [{\n        type: Host\n      }]\n    }];\n  }, {\n    target: [{\n      type: Input,\n      args: ['swalPortal']\n    }]\n  });\n})();\nfunction provideDefaultSwal() {\n  return import('sweetalert2');\n}\nclass SweetAlert2Module {\n  static forRoot(options = {}) {\n    return {\n      ngModule: SweetAlert2Module,\n      providers: [SweetAlert2LoaderService, {\n        provide: swalProviderToken,\n        useValue: options.provideSwal || provideDefaultSwal\n      }, {\n        provide: fireOnInitToken,\n        useValue: options.fireOnInit || false\n      }, {\n        provide: dismissOnDestroyToken,\n        useValue: options.dismissOnDestroy || true\n      }]\n    };\n  }\n  static forChild(options = {}) {\n    return {\n      ngModule: SweetAlert2Module,\n      providers: [...(options.provideSwal ? [SweetAlert2LoaderService, {\n        provide: swalProviderToken,\n        useValue: options.provideSwal\n      }] : []), ...(options.fireOnInit !== undefined ? [{\n        provide: fireOnInitToken,\n        useValue: options.fireOnInit\n      }] : []), ...(options.dismissOnDestroy !== undefined ? [{\n        provide: dismissOnDestroyToken,\n        useValue: options.dismissOnDestroy\n      }] : [])]\n    };\n  }\n  static ɵfac = function SweetAlert2Module_Factory(t) {\n    return new (t || SweetAlert2Module)();\n  };\n  static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: SweetAlert2Module\n  });\n  static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule]\n  });\n}\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SweetAlert2Module, [{\n    type: NgModule,\n    args: [{\n      declarations: [SwalDirective, SwalComponent, SwalPortalDirective, SwalPortalComponent],\n      imports: [CommonModule],\n      exports: [SwalComponent, SwalPortalDirective, SwalDirective]\n    }]\n  }], null, null);\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { SwalComponent, SwalDirective, SwalPortalDirective, SwalPortalTargets, SweetAlert2LoaderService, SweetAlert2Module };","map":{"version":3,"names":["i0","ɵɵelementContainer","swalProviderToken","InjectionToken","fireOnInitToken","dismissOnDestroyToken","SweetAlert2LoaderService","swalProvider","swalPromiseCache","constructor","swal","preloadSweetAlertLibrary","libPromise","isLoader","Promise","resolve","then","value","isDefaultExport","default","version","undefined","ɵfac","SweetAlert2LoaderService_Factory","t","ɵɵinject","ɵɵdefineInjectable","token","factory","ɵsetClassMetadata","Injectable","Inject","SwalComponent","sweetAlert2Loader","moduleLevelFireOnInit","moduleLevelDismissOnDestroy","title","titleText","text","html","footer","icon","iconColor","iconHtml","backdrop","toast","target","input","width","padding","background","position","grow","showClass","hideClass","customClass","timer","timerProgressBar","heightAuto","allowOutsideClick","allowEscapeKey","allowEnterKey","stopKeydownPropagation","keydownListenerCapture","showConfirmButton","showDenyButton","showCancelButton","confirmButtonText","denyButtonText","cancelButtonText","confirmButtonColor","denyButtonColor","cancelButtonColor","confirmButtonAriaLabel","denyButtonAriaLabel","cancelButtonAriaLabel","buttonsStyling","reverseButtons","focusConfirm","focusDeny","focusCancel","showCloseButton","closeButtonHtml","closeButtonAriaLabel","loaderHtml","showLoaderOnConfirm","preConfirm","preDeny","imageUrl","imageWidth","imageHeight","imageAlt","inputLabel","inputPlaceholder","inputValue","inputOptions","inputAutoTrim","inputAttributes","inputValidator","returnInputValueOnDeny","validationMessage","progressSteps","currentProgressStep","progressStepsDistance","scrollbarPadding","swalOptions","options","Object","assign","touchedKeys","keys","forEach","markTouched","touchedProps","reduce","obj","key","swalFireOnInit","swalDismissOnDestroy","swalVisible","visible","fire","close","isCurrentlyShown","willOpen","EventEmitter","didOpen","didRender","willClose","didClose","didDestroy","confirm","deny","dismiss","Set","add","bind","ngOnInit","ngAfterViewInit","fireOnInit","ngOnChanges","changes","filter","startsWith","update","ngOnDestroy","dismissOnDestroy","_this","_asyncToGenerator","userOptions","composeHook","modalElement","emit","result","isConfirmed","isDenied","isDismissed","userHook","libHook","args","_this2","_this3","allOptions","updatableOptions","isUpdatableParameter","ɵɵdirectiveInject","ɵcmp","ɵɵdefineComponent","type","selectors","inputs","outputs","features","ɵɵNgOnChangesFeature","decls","vars","template","SwalComponent_Template","rf","ctx","encapsulation","changeDetection","Component","selector","ChangeDetectionStrategy","OnPush","Input","Output","SwalDirective","viewContainerRef","resolver","swalInstance","isArrayOptions","Array","isArray","swalRef","resolveComponentFactory","createComponent","instance","destroy","onClick","event","preventDefault","stopImmediatePropagation","stopPropagation","swalClosed","Subject","asObservable","pipe","takeUntil","subscribe","v","next","ViewContainerRef","ComponentFactoryResolver","ɵɵdefineDirective","hostBindings","SwalDirective_HostBindings","ɵɵlistener","SwalDirective_click_HostBindingHandler","$event","Directive","HostListener","SwalPortalComponent","consts","SwalPortalComponent_Template","ɵɵtemplate","SwalPortalComponent_ng_container_0_Template","ɵɵproperty","dependencies","i1","NgTemplateOutlet","SwalPortalTargets","closeButton","element","getCloseButton","getTitle","content","getHtmlContainer","actions","getActions","confirmButton","getConfirmButton","denyButton","getDenyButton","cancelButton","getCancelButton","getFooter","ɵprov","providedIn","SwalPortalDirective","injector","app","templateRef","swalTargets","swalComponent","portalComponentRef","destroyed","didRenderHook","willOpenHook","didDestroyHook","_this4","createPortalComponent","targetEl","firstChild","removeChild","appendChild","location","nativeElement","attachView","hostView","detachView","componentRef","create","Injector","ApplicationRef","TemplateRef","Host","provideDefaultSwal","SweetAlert2Module","forRoot","ngModule","providers","provide","useValue","provideSwal","forChild","ɵmod","ɵɵdefineNgModule","ɵinj","ɵɵdefineInjector","imports","CommonModule","NgModule","declarations","exports"],"sources":["C:\\Users\\eftel\\Documents\\AngularLearn\\learn-angular\\node_modules\\projects\\ngx-sweetalert2\\src\\lib\\di.ts","C:\\Users\\eftel\\Documents\\AngularLearn\\learn-angular\\node_modules\\projects\\ngx-sweetalert2\\src\\lib\\sweetalert2-loader.service.ts","C:\\Users\\eftel\\Documents\\AngularLearn\\learn-angular\\node_modules\\projects\\ngx-sweetalert2\\src\\lib\\swal.component.ts","C:\\Users\\eftel\\Documents\\AngularLearn\\learn-angular\\node_modules\\projects\\ngx-sweetalert2\\src\\lib\\swal.directive.ts","C:\\Users\\eftel\\Documents\\AngularLearn\\learn-angular\\node_modules\\projects\\ngx-sweetalert2\\src\\lib\\swal-portal.component.ts","C:\\Users\\eftel\\Documents\\AngularLearn\\learn-angular\\node_modules\\projects\\ngx-sweetalert2\\src\\lib\\swal-portal-targets.service.ts","C:\\Users\\eftel\\Documents\\AngularLearn\\learn-angular\\node_modules\\projects\\ngx-sweetalert2\\src\\lib\\swal-portal.directive.ts","C:\\Users\\eftel\\Documents\\AngularLearn\\learn-angular\\node_modules\\projects\\ngx-sweetalert2\\src\\lib\\sweetalert2.module.ts","C:\\Users\\eftel\\Documents\\AngularLearn\\learn-angular\\node_modules\\projects\\ngx-sweetalert2\\src\\sweetalert2-ngx-sweetalert2.ts"],"sourcesContent":["import { InjectionToken } from '@angular/core';\nimport Swal from 'sweetalert2';\n\nexport const swalProviderToken = new InjectionToken<typeof Swal>('@sweetalert2/ngx-sweetalert2#swalProvider');\n\nexport const fireOnInitToken = new InjectionToken<boolean>('@sweetalert2/ngx-sweetalert2#fireOnInit');\n\nexport const dismissOnDestroyToken = new InjectionToken<boolean>('@sweetalert2/ngx-sweetalert2#dismissOnDestroy');\n","import { Inject, Injectable } from '@angular/core';\nimport SwalDefault, * as Swal from 'sweetalert2';\nimport { swalProviderToken } from './di';\n\nexport type SwalModule = typeof SwalDefault | typeof Swal;\n\nexport type SwalProvider = SwalModuleLoader | SwalModule;\n\nexport type SwalModuleLoader = () => Promise<SwalModule>;\n\n@Injectable()\nexport class SweetAlert2LoaderService {\n    private readonly swalProvider: SwalProvider;\n\n    private swalPromiseCache?: Promise<typeof SwalDefault>;\n\n    // Using any because Angular metadata generator does not understand a pure TS type here\n    public constructor(@Inject(swalProviderToken) swalProvider: any) {\n        this.swalProvider = swalProvider;\n    }\n\n    public get swal(): Promise<typeof SwalDefault> {\n        if (!this.swalPromiseCache) {\n            this.preloadSweetAlertLibrary();\n        }\n\n        return this.swalPromiseCache!;\n    }\n\n    public preloadSweetAlertLibrary(): void {\n        if (this.swalPromiseCache) return;\n\n        const libPromise = isLoader(this.swalProvider)\n            ? this.swalProvider()\n            : Promise.resolve(this.swalProvider);\n\n        this.swalPromiseCache = libPromise.then(value => isDefaultExport(value) ? value : value.default);\n\n        function isLoader(value: SwalProvider): value is SwalModuleLoader {\n            return typeof value === 'function' && (value as any).version === undefined;\n        }\n\n        function isDefaultExport(value: SwalModule): value is typeof SwalDefault {\n            return typeof value === 'function';\n        }\n    }\n}\n","import {\n    AfterViewInit, ChangeDetectionStrategy, Component, EventEmitter, Inject, Input, OnChanges, OnDestroy, OnInit,\n    Output, SimpleChanges\n} from '@angular/core';\nimport Swal, { SweetAlertOptions, SweetAlertResult, SweetAlertUpdatableParameters } from 'sweetalert2';\nimport { dismissOnDestroyToken, fireOnInitToken } from './di';\nimport * as events from './swal-events';\nimport { SweetAlert2LoaderService } from './sweetalert2-loader.service';\n\n/**\n * <swal> component. See the README.md for usage.\n *\n * It contains a bunch of @Inputs that have a perfect 1:1 mapping with SweetAlert2 options.\n * Their types are directly coming from SweetAlert2 types defintitions, meaning that ngx-sweetalert2 is tightly coupled\n * to SweetAlert2, but also is type-safe even if both libraries do not evolve in sync.\n *\n * (?) If you want to use an object that declares the SweetAlert2 options all at once rather than many @Inputs,\n *     take a look at [swalOptions], that lets you pass a full {@link SweetAlertOptions} object.\n *\n * (?) If you are reading the TypeScript source of this component, you may think that it's a lot of code.\n *     Be sure that a lot of this code is types and Angular boilerplate. Compiled and minified code is much smaller.\n *     If you are really concerned about performance and/or don't care about the API and its convenient integration\n *     with Angular (notably change detection and transclusion), you may totally use SweetAlert2 natively as well ;)\n *\n * /!\\ Some SweetAlert options aren't @Inputs but @Outputs: `willOpen`, `didOpen`, `didRender`, `willClose`, `didClose`\n *     and `didDestroy`.\n *     However, `preConfirm`, `preDeny` and `inputValidator` are still @Inputs because they are not event handlers,\n *     there can't be multiple listeners on them, and we need the values they can/must return.\n */\n@Component({\n    selector: 'swal',\n    template: '',\n    changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class SwalComponent implements OnInit, AfterViewInit, OnChanges, OnDestroy {\n    @Input() public title: SweetAlertOptions['title'];\n    @Input() public titleText: SweetAlertOptions['titleText'];\n    @Input() public text: SweetAlertOptions['text'];\n    @Input() public html: SweetAlertOptions['html'];\n    @Input() public footer: SweetAlertOptions['footer'];\n    @Input() public icon: SweetAlertOptions['icon'];\n    @Input() public iconColor: SweetAlertOptions['iconColor'];\n    @Input() public iconHtml: SweetAlertOptions['iconHtml'];\n    @Input() public backdrop: SweetAlertOptions['backdrop'];\n    @Input() public toast: SweetAlertOptions['toast'];\n    @Input() public target: SweetAlertOptions['target'];\n    @Input() public input: SweetAlertOptions['input'];\n    @Input() public width: SweetAlertOptions['width'];\n    @Input() public padding: SweetAlertOptions['padding'];\n    @Input() public background: SweetAlertOptions['background'];\n    @Input() public position: SweetAlertOptions['position'];\n    @Input() public grow: SweetAlertOptions['grow'];\n    @Input() public showClass: SweetAlertOptions['showClass'];\n    @Input() public hideClass: SweetAlertOptions['hideClass'];\n    @Input() public customClass: SweetAlertOptions['customClass'];\n    @Input() public timer: SweetAlertOptions['timer'];\n    @Input() public timerProgressBar: SweetAlertOptions['timerProgressBar'];\n    @Input() public heightAuto: SweetAlertOptions['heightAuto'];\n    @Input() public allowOutsideClick: SweetAlertOptions['allowOutsideClick'];\n    @Input() public allowEscapeKey: SweetAlertOptions['allowEscapeKey'];\n    @Input() public allowEnterKey: SweetAlertOptions['allowEnterKey'];\n    @Input() public stopKeydownPropagation: SweetAlertOptions['stopKeydownPropagation'];\n    @Input() public keydownListenerCapture: SweetAlertOptions['keydownListenerCapture'];\n    @Input() public showConfirmButton: SweetAlertOptions['showConfirmButton'];\n    @Input() public showDenyButton: SweetAlertOptions['showDenyButton'];\n    @Input() public showCancelButton: SweetAlertOptions['showCancelButton'];\n    @Input() public confirmButtonText: SweetAlertOptions['confirmButtonText'];\n    @Input() public denyButtonText: SweetAlertOptions['denyButtonText'];\n    @Input() public cancelButtonText: SweetAlertOptions['cancelButtonText'];\n    @Input() public confirmButtonColor: SweetAlertOptions['confirmButtonColor'];\n    @Input() public denyButtonColor: SweetAlertOptions['denyButtonColor'];\n    @Input() public cancelButtonColor: SweetAlertOptions['cancelButtonColor'];\n    @Input() public confirmButtonAriaLabel: SweetAlertOptions['confirmButtonAriaLabel'];\n    @Input() public denyButtonAriaLabel: SweetAlertOptions['denyButtonAriaLabel'];\n    @Input() public cancelButtonAriaLabel: SweetAlertOptions['cancelButtonAriaLabel'];\n    @Input() public buttonsStyling: SweetAlertOptions['buttonsStyling'];\n    @Input() public reverseButtons: SweetAlertOptions['reverseButtons'];\n    @Input() public focusConfirm: SweetAlertOptions['focusConfirm'];\n    @Input() public focusDeny: SweetAlertOptions['focusDeny'];\n    @Input() public focusCancel: SweetAlertOptions['focusCancel'];\n    @Input() public showCloseButton: SweetAlertOptions['showCloseButton'];\n    @Input() public closeButtonHtml: SweetAlertOptions['closeButtonHtml'];\n    @Input() public closeButtonAriaLabel: SweetAlertOptions['closeButtonAriaLabel'];\n    @Input() public loaderHtml: SweetAlertOptions['loaderHtml'];\n    @Input() public showLoaderOnConfirm: SweetAlertOptions['showLoaderOnConfirm'];\n    @Input() public preConfirm: SweetAlertOptions['preConfirm'];\n    @Input() public preDeny: SweetAlertOptions['preDeny'];\n    @Input() public imageUrl: SweetAlertOptions['imageUrl'];\n    @Input() public imageWidth: SweetAlertOptions['imageWidth'];\n    @Input() public imageHeight: SweetAlertOptions['imageHeight'];\n    @Input() public imageAlt: SweetAlertOptions['imageAlt'];\n    @Input() public inputLabel: SweetAlertOptions['inputLabel'];\n    @Input() public inputPlaceholder: SweetAlertOptions['inputPlaceholder'];\n    @Input() public inputValue: SweetAlertOptions['inputValue'];\n    @Input() public inputOptions: SweetAlertOptions['inputOptions'];\n    @Input() public inputAutoTrim: SweetAlertOptions['inputAutoTrim'];\n    @Input() public inputAttributes: SweetAlertOptions['inputAttributes'];\n    @Input() public inputValidator: SweetAlertOptions['inputValidator'];\n    @Input() public returnInputValueOnDeny: SweetAlertOptions['returnInputValueOnDeny'];\n    @Input() public validationMessage: SweetAlertOptions['validationMessage'];\n    @Input() public progressSteps: SweetAlertOptions['progressSteps'];\n    @Input() public currentProgressStep: SweetAlertOptions['currentProgressStep'];\n    @Input() public progressStepsDistance: SweetAlertOptions['progressStepsDistance'];\n    @Input() public scrollbarPadding: SweetAlertOptions['scrollbarPadding'];\n\n    /**\n     * An object of SweetAlert2 native options, useful if:\n     *  - you don't want to use the @Inputs for practical/philosophical reasons ;\n     *  - there are missing @Inputs because ngx-sweetalert2 isn't up-to-date with SweetAlert2's latest changes.\n     *\n     * /!\\ Please note that setting this property does NOT erase what has been set before unless you specify the\n     *     previous properties you want to erase again.\n     *     Ie. setting { title: 'Title' } and then { text: 'Text' } will give { title: 'Title', text: 'Text' }.\n     *\n     * /!\\ Be aware that the options defined in this object will override the @Inputs of the same name.\n     */\n    @Input()\n    public set swalOptions(options: SweetAlertOptions) {\n        //=> Update properties\n        Object.assign(this, options);\n\n        //=> Mark changed properties as touched\n        const touchedKeys = Object.keys(options) as Array<keyof SweetAlertOptions>;\n        touchedKeys.forEach(this.markTouched);\n    }\n\n    /**\n     * Computes the options object that will get passed to SweetAlert2.\n     * Only the properties that have been set at least once on this component will be returned.\n     * Mostly for internal usage.\n     */\n    public get swalOptions(): SweetAlertOptions {\n        //=> We will compute the options object based on the option keys that are known to have changed.\n        //   That avoids passing a gigantic object to SweetAlert2, making debugging easier and potentially\n        //   avoiding side effects.\n        return [...this.touchedProps].reduce<SweetAlertOptions>(\n            (obj, key) => ({ ...obj, [key]: this[key as keyof this] }),\n            {});\n    }\n\n    /**\n     * Whether to fire the modal as soon as the <swal> component is created and initialized in the view.\n     * When left undefined (default), the value will be inherited from the module configuration, which is `false`.\n     *\n     * Example:\n     *     <swal *ngIf=\"error\" [title]=\"error.title\" [text]=\"error.text\" icon=\"error\" [swalFireOnInit]=\"true\"></swal>\n     */\n    @Input()\n    public swalFireOnInit?: boolean;\n\n    /**\n     * Whether to dismiss the modal when the <swal> component is destroyed by Angular (for any reason) or not.\n     * When left undefined (default), the value will be inherited from the module configuration, which is `true`.\n     */\n    @Input()\n    public swalDismissOnDestroy?: boolean;\n\n    @Input()\n    public set swalVisible(visible: boolean) {\n        visible ? this.fire() : this.close();\n    }\n\n    public get swalVisible(): boolean {\n        return this.isCurrentlyShown;\n    }\n\n    /**\n     * Modal lifecycle hook. Synchronously runs before the modal is shown on screen.\n     */\n    @Output()\n    public readonly willOpen = new EventEmitter<events.WillOpenEvent>();\n\n    /**\n     * Modal lifecycle hook. Synchronously runs before the modal is shown on screen.\n     */\n    @Output()\n    public readonly didOpen = new EventEmitter<events.DidOpenEvent>();\n\n    /**\n     * Modal lifecycle hook. Synchronously runs after the popup DOM has been updated (ie. just before the modal is\n     * repainted on the screen).\n     * Typically, this will happen after `Swal.fire()` or `Swal.update()`.\n     * If you want to perform changes in the popup's DOM, that survive `Swal.update()`, prefer {@link didRender} over\n     * {@link willOpen}.\n     */\n    @Output()\n    public readonly didRender = new EventEmitter<events.DidRenderEvent>();\n\n    /**\n     * Modal lifecycle hook. Synchronously runs when the popup closes by user interaction (and not due to another popup\n     * being fired).\n     */\n    @Output()\n    public readonly willClose = new EventEmitter<events.WillCloseEvent>();\n\n    /**\n     * Modal lifecycle hook. Asynchronously runs after the popup has been disposed by user interaction (and not due to\n     * another popup being fired).\n     */\n    @Output()\n    public readonly didClose = new EventEmitter<void>();\n\n    /**\n     * Modal lifecycle hook. Synchronously runs after popup has been destroyed either by user interaction or by another\n     * popup.\n     * If you have cleanup operations that you need to reliably execute each time a modal is closed, prefer\n     * {@link didDestroy} over {@link didClose}.\n     */\n    @Output()\n    public readonly didDestroy = new EventEmitter<void>();\n\n    /**\n     * Emits when the user clicks \"Confirm\".\n     * The event value ($event) can be either:\n     *  - by default, just `true`,\n     *  - when using {@link input}, the input value,\n     *  - when using {@link preConfirm}, the return value of this function.\n     *\n     * Example:\n     *     <swal (confirm)=\"handleConfirm($event)\"></swal>\n     *\n     *     public handleConfirm(email: string): void {\n     *         // ... save user email\n     *     }\n     */\n    @Output()\n    public readonly confirm = new EventEmitter<any>();\n\n    /**\n     * Emits when the user clicks \"Deny\".\n     * This event bears no value.\n     * Use `(deny)` (along with {@link showDenyButton}) when you want a modal with three buttons (confirm, deny and\n     * cancel), and/or when you want to handle clear refusal in a separate way than simple dismissal.\n     *\n     * Example:\n     *     <swal (deny)=\"handleDeny()\"></swal>\n     *\n     *     public handleDeny(): void {\n     *     }\n     */\n    @Output()\n    public readonly deny = new EventEmitter<void>();\n\n    /**\n     * Emits when the user clicks \"Cancel\", or dismisses the modal by any other allowed way.\n     * The event value ($event) is a string that explains how the modal was dismissed. It is `undefined` when\n     * the modal was programmatically closed (through {@link close} for example).\n     *\n     * Example:\n     *     <swal (dismiss)=\"handleDismiss($event)\"></swal>\n     *\n     *     public handleDismiss(reason: DismissReason | undefined): void {\n     *         // reason can be 'cancel', 'overlay', 'close', 'timer' or undefined.\n     *         // ... do something\n     *     }\n     */\n    @Output()\n    public readonly dismiss = new EventEmitter<Swal.DismissReason | undefined>();\n\n    /**\n     * This Set retains the properties that have been changed from @Inputs, so we can know precisely\n     * what options we have to send to {@link Swal.fire}.\n     */\n    private readonly touchedProps = new Set<keyof SweetAlertOptions>();\n\n    /**\n     * A function of signature `(propName: string): void` that adds a given property name to the list of\n     * touched properties, ie. {@link touchedProps}.\n     */\n    private readonly markTouched = this.touchedProps.add.bind(this.touchedProps);\n\n    /**\n     * Is the SweetAlert2 modal represented by this component currently opened?\n     */\n    private isCurrentlyShown = false;\n\n    public constructor(\n        private readonly sweetAlert2Loader: SweetAlert2LoaderService,\n        @Inject(fireOnInitToken) private readonly moduleLevelFireOnInit: boolean,\n        @Inject(dismissOnDestroyToken) private readonly moduleLevelDismissOnDestroy: boolean) {\n    }\n\n    /**\n     * Angular lifecycle hook.\n     * Asks the SweetAlert2 loader service to preload the SweetAlert2 library, so it begins to be loaded only if there\n     * is a <swal> component somewhere, and is probably fully loaded when the modal has to be displayed,\n     * causing no delay.\n     */\n    public ngOnInit(): void {\n        //=> Preload SweetAlert2 library in case this component is activated.\n        this.sweetAlert2Loader.preloadSweetAlertLibrary();\n    }\n\n    /**\n     * Angular lifecycle hook.\n     * Fires the modal, if the component or module is configured to do so.\n     */\n    public ngAfterViewInit(): void {\n        const fireOnInit = this.swalFireOnInit === undefined\n            ? this.moduleLevelFireOnInit\n            : this.swalFireOnInit;\n\n        fireOnInit && this.fire();\n    }\n\n    /**\n     * Angular lifecycle hook.\n     * Updates the SweetAlert options, and if the modal is opened, asks SweetAlert to render it again.\n     */\n    public ngOnChanges(changes: SimpleChanges): void {\n        //=> For each changed @Input that matches a SweetAlert2 option, mark as touched so we can\n        //   send it with the next fire() or update() calls.\n        Object.keys(changes)\n            //=> If the filtering logic becomes more complex here, we can use Swal.isValidParameter\n            .filter((key): key is keyof SweetAlertOptions => !key.startsWith('swal'))\n            .forEach(this.markTouched);\n\n        //=> Eventually trigger re-render if the modal is open.\n        void this.update();\n    }\n\n    /**\n     * Angular lifecycle hook.\n     * Closes the SweetAlert when the component is destroyed.\n     */\n    public ngOnDestroy(): void {\n        //=> Release the modal if the component is destroyed and if that behaviour is not disabled.\n        const dismissOnDestroy = this.swalDismissOnDestroy === undefined\n            ? this.moduleLevelDismissOnDestroy\n            : this.swalDismissOnDestroy;\n\n        dismissOnDestroy && this.close();\n    }\n\n    /**\n     * Shows the SweetAlert.\n     *\n     * Returns the SweetAlert2 promise for convenience and use in code behind templates.\n     * Otherwise, (confirm)=\"myHandler($event)\" and (dismiss)=\"myHandler($event)\" can be used in templates.\n     */\n    public async fire(): Promise<SweetAlertResult> {\n        const swal = await this.sweetAlert2Loader.swal;\n\n        const userOptions = this.swalOptions;\n\n        //=> Build the SweetAlert2 options\n        const options: SweetAlertOptions = {\n            //=> Merge with calculated options set for that specific swal\n            ...userOptions,\n\n            //=> Handle modal lifecycle events\n            willOpen: composeHook(userOptions.willOpen, (modalElement) => {\n                this.willOpen.emit({ modalElement });\n            }),\n            didOpen: composeHook(userOptions.didOpen, (modalElement) => {\n                this.isCurrentlyShown = true;\n                this.didOpen.emit({ modalElement });\n            }),\n            didRender: composeHook(userOptions.didRender, (modalElement) => {\n                this.didRender.emit({ modalElement });\n            }),\n            willClose: composeHook(userOptions.willClose, (modalElement) => {\n                this.isCurrentlyShown = false;\n                this.willClose.emit({ modalElement });\n            }),\n            didClose: composeHook(userOptions.didClose, () => {\n                this.didClose.emit();\n            }),\n            didDestroy: composeHook(userOptions.didDestroy, () => {\n                this.didDestroy.emit();\n            })\n        };\n\n        //=> Show the Swal! And wait for confirmation or dimissal.\n        const result = await swal.fire(options);\n\n        //=> Emit on (confirm), (deny) or (dismiss)\n        switch (true) {\n            case result.isConfirmed: this.confirm.emit(result.value); break;\n            case result.isDenied: this.deny.emit(); break;\n            case result.isDismissed: this.dismiss.emit(result.dismiss); break;\n        }\n\n        return result;\n\n        function composeHook<T extends (...args: any[]) => void>(\n            userHook: T | undefined,\n            libHook: T): (...args: Parameters<T>) => void {\n\n            return (...args) => (libHook(...args), userHook?.(...args));\n        }\n    }\n\n    /**\n     * Closes the modal, if opened.\n     *\n     * @param result The value that the modal will resolve with, triggering either (confirm), (deny) or (dismiss).\n     *               If the argument is not passed, it is (dismiss) that will emit an `undefined` reason.\n     *               {@see Swal.close}.\n     */\n    public async close(result?: SweetAlertResult): Promise<void> {\n        if (!this.isCurrentlyShown) return;\n\n        const swal = await this.sweetAlert2Loader.swal;\n        swal.close(result);\n    }\n\n    /**\n     * Updates SweetAlert2 options while the modal is opened, causing the modal to re-render.\n     * If the modal is not opened, the component options will simply be updated and that's it.\n     *\n     * /!\\ Please note that not all SweetAlert2 options are updatable while the modal is opened.\n     *\n     * @param options\n     */\n    public async update(options?: Pick<SweetAlertOptions, SweetAlertUpdatableParameters>): Promise<void> {\n        if (options) {\n            this.swalOptions = options;\n        }\n\n        if (!this.isCurrentlyShown) return;\n\n        const swal = await this.sweetAlert2Loader.swal;\n\n        const allOptions = this.swalOptions;\n\n        const updatableOptions = Object.keys(allOptions)\n            .filter(swal.isUpdatableParameter)\n            .reduce<Pick<SweetAlertOptions, SweetAlertUpdatableParameters>>(\n                (obj, key) => ({ ...obj, [key]: allOptions[key] }),\n                {});\n\n        swal.update(updatableOptions);\n    }\n}\n","import {\n    ComponentFactoryResolver, ComponentRef, Directive, EventEmitter, HostListener, Input, OnDestroy, OnInit, Output,\n    ViewContainerRef\n} from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\nimport Swal, { SweetAlertArrayOptions, SweetAlertOptions } from 'sweetalert2';\nimport { SwalComponent } from './swal.component';\n\n/**\n * [swal] directive. It takes a value that defines the SweetAlert and can be of three types:\n *\n * 1) A simple array of two or three strings defining [title, text, icon] - the icon being optional, ex:\n *\n *    <button [swal]=\"['Title', 'Text']\">Click me</button>\n *\n * 2) A native SweetAlert2 options object, ex:\n *\n *    <button [swal]=\"{ title: 'Title', text: 'Text' }\">Click me</button>\n *\n * 3) A reference to an existing SwalComponent instance for more advanced uses, ex:\n *\n *    <button [swal]=\"mySwal\">Click me</button>\n *    <swal #mySwal title=\"Title\" text=\"Text\"></swal>\n */\n@Directive({\n    selector: '[swal]'\n})\nexport class SwalDirective implements OnInit, OnDestroy {\n    /**\n     * SweetAlert2 options or a SwalComponent instance.\n     * See the class doc block for more informations.\n     */\n    @Input()\n    public set swal(options: SwalComponent | SweetAlertOptions | SweetAlertArrayOptions) {\n        if (options instanceof SwalComponent) {\n            this.swalInstance = options;\n        } else if (isArrayOptions(options)) {\n            this.swalOptions = {};\n            [this.swalOptions.title, this.swalOptions.text, this.swalOptions.icon] = options;\n        } else {\n            this.swalOptions = options;\n        }\n\n        function isArrayOptions(value: any): value is SweetAlertArrayOptions {\n            return Array.isArray(options);\n        }\n    }\n\n    /**\n     * Emits when the user clicks \"Confirm\".\n     * The event value ($event) can be either:\n     *  - by default, just `true`,\n     *  - when using {@link input}, the input value,\n     *  - when using {@link preConfirm}, the return value of this function.\n     *\n     * Example:\n     *     <swal (confirm)=\"handleConfirm($event)\"></swal>\n     *\n     *     public handleConfirm(email: string): void {\n     *         // ... save user email\n     *     }\n     */\n    @Output()\n    public readonly confirm = new EventEmitter<any>();\n\n    /**\n     * Emits when the user clicks \"Deny\".\n     * This event bears no value.\n     * Use `(deny)` (along with {@link showDenyButton}) when you want a modal with three buttons (confirm, deny and\n     * cancel), and/or when you want to handle clear refusal in a separate way than simple dismissal.\n     *\n     * Example:\n     *     <swal (deny)=\"handleDeny()\"></swal>\n     *\n     *     public handleDeny(): void {\n     *     }\n     */\n    @Output()\n    public readonly deny = new EventEmitter<void>();\n\n    /**\n     * Emits when the user clicks \"Cancel\", or dismisses the modal by any other allowed way.\n     * The event value ($event) is a string that explains how the modal was dismissed. It is `undefined` when\n     * the modal was programmatically closed (through {@link dismiss} for example).\n     *\n     * Example:\n     *     <swal (dismiss)=\"handleDismiss($event)\"></swal>\n     *\n     *     public handleDismiss(reason: DismissReason | undefined): void {\n     *         // reason can be 'cancel', 'overlay', 'close', 'timer' or undefined.\n     *         // ... do something\n     *     }\n     */\n    @Output()\n    public readonly dismiss = new EventEmitter<Swal.DismissReason | undefined>();\n\n    /**\n     * When the user does not provides a SwalComponent instance, we create it on-the-fly and assign the plain-object\n     * options to it.\n     * This fields keeps a reference to the dynamically-created <swal>, to destroy it along this directive instance.\n     */\n    private swalRef?: ComponentRef<SwalComponent>;\n\n    /**\n     * An instance of the <swal> component that this directive controls.\n     * Could be an instance passed by the user, otherwise it's the instance we've dynamically created.\n     */\n    private swalInstance?: SwalComponent;\n\n    /**\n     * Holds the native SweetAlert2 options.\n     * Empty when the user passed an existing SwalComponent instance.\n     */\n    private swalOptions?: SweetAlertOptions;\n\n    public constructor(\n        private readonly viewContainerRef: ViewContainerRef,\n        private readonly resolver: ComponentFactoryResolver) {\n    }\n\n    /**\n     * OnInit lifecycle handler.\n     * Creates a SwalComponent instance if the user didn't provided one and binds on that component (confirm),\n     * (deny) and (dismiss) outputs to reemit on the directive.\n     */\n    public ngOnInit(): void {\n        if (!this.swalInstance) {\n            const factory = this.resolver.resolveComponentFactory(SwalComponent);\n\n            this.swalRef = this.viewContainerRef.createComponent(factory);\n            this.swalInstance = this.swalRef.instance;\n        }\n    }\n\n    /**\n     * OnDestroy lifecycle handler.\n     * Destroys the dynamically-created SwalComponent.\n     */\n    public ngOnDestroy(): void {\n        if (this.swalRef) {\n            this.swalRef.destroy();\n        }\n    }\n\n    /**\n     * Click handler.\n     * The directive listens for onclick events on its host element.\n     * When this happens, it shows the <swal> attached to this directive.\n     */\n    @HostListener('click', ['$event'])\n    public onClick(event: MouseEvent): void {\n        event.preventDefault();\n        event.stopImmediatePropagation();\n        event.stopPropagation();\n\n        if (!this.swalInstance) return;\n\n        if (this.swalOptions) {\n            this.swalInstance.swalOptions = this.swalOptions;\n        }\n\n        const swalClosed = new Subject<void>();\n\n        this.swalInstance.confirm.asObservable().pipe(takeUntil(swalClosed)).subscribe(v => this.confirm.emit(v));\n        this.swalInstance.deny.asObservable().pipe(takeUntil(swalClosed)).subscribe(v => this.deny.emit(v));\n        this.swalInstance.dismiss.asObservable().pipe(takeUntil(swalClosed)).subscribe(v => this.dismiss.emit(v));\n\n        this.swalInstance.fire().then(() => swalClosed.next());\n    }\n}\n","import { ChangeDetectionStrategy, Component, Input, TemplateRef } from '@angular/core';\n\n/**\n * @internal\n * Holds a consumer's Angular template and displays it on a Sweet Alert.\n * See SwalPortalDirective for info about the covered feature.\n */\n@Component({\n    selector: 'swal-portal',\n    template: '<ng-container *ngTemplateOutlet=\"template\"></ng-container>',\n    changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class SwalPortalComponent {\n    @Input()\n    public template: TemplateRef<any> | null = null;\n}\n","import { Injectable } from '@angular/core';\nimport Swal, { SweetAlertOptions } from 'sweetalert2';\n\nexport interface SwalPortalTarget {\n    options?: SweetAlertOptions;\n    element(swal: typeof Swal): HTMLElement | null;\n}\n\n/**\n * Represents an object of targets for <swal> portals (use with *swalPortal directive).\n * We must use thunks to access the Swal.* functions listed below, because they get created after the first modal is\n * shown, so this object lets us reference those functions safely and in a statically-typed manner.\n */\n@Injectable({ providedIn: 'root' })\nexport class SwalPortalTargets {\n    /**\n     * Targets the modal close button block contents.\n     */\n    public readonly closeButton: SwalPortalTarget = {\n        element: swal => swal.getCloseButton(),\n        options: { showCloseButton: true }\n    };\n\n    /**\n     * Targets the modal title block contents.\n     */\n    public readonly title: SwalPortalTarget = {\n        element: swal => swal.getTitle(),\n        // Empty text that will never be shown but necessary so SweetAlert2 makes the div visible.\n        options: { title: ' ' }\n    };\n\n    /**\n     * Targets the modal text block contents (that is another block inside the first content block, so you can still\n     * use other modal features like Swal inputs, that are situated inside that parent content block).\n     */\n    public readonly content: SwalPortalTarget = {\n        element: swal => swal.getHtmlContainer(),\n        // Empty text that will never be shown but necessary so SweetAlert2 makes the div visible.\n        options: { text: ' ' }\n    };\n\n    /**\n     * Targets the actions block contents, where are the confirm and cancel buttons in a normal time.\n     * /!\\ WARNING: using this target destroys some of the native SweetAlert2 modal's DOM, therefore, if you use this\n     *     target, do not update the modal via <swal> @Inputs while the modal is open, or you'll get an error.\n     *     We could workaround that inconvenient inside this integration, but that'd be detrimental to memory and\n     *     performance of everyone, for a relatively rare use case.\n     */\n    public readonly actions: SwalPortalTarget = {\n        element: swal => swal.getActions(),\n        // The button will never exist, but SweetAlert2 shows the actions block only if there is at least one button.\n        options: { showConfirmButton: true }\n    };\n\n    /**\n     * Targets the confirm button contents, replacing the text inside it (not the button itself)\n     */\n    public readonly confirmButton: SwalPortalTarget = {\n        element: swal => swal.getConfirmButton(),\n        options: { showConfirmButton: true }\n    };\n\n    /**\n     * Targets the deny button contents, replacing the text inside it (not the button itself)\n     */\n    public readonly denyButton: SwalPortalTarget = {\n        element: swal => swal.getDenyButton(),\n        options: { showDenyButton: true }\n    };\n\n    /**\n     * Targets the cancel button contents, replacing the text inside it (not the button itself)\n     */\n    public readonly cancelButton: SwalPortalTarget = {\n        element: swal => swal.getCancelButton(),\n        options: { showCancelButton: true }\n    };\n\n    /**\n     * Targets the modal footer contents.\n     */\n    public readonly footer: SwalPortalTarget = {\n        element: swal => swal.getFooter(),\n        // Empty text that will never be shown but necessary so SweetAlert2 makes the div visible.\n        options: { footer: ' ' }\n    };\n}\n","import {\n    ApplicationRef, ComponentFactoryResolver, ComponentRef, Directive, Host, Injector, Input, OnDestroy, OnInit,\n    TemplateRef\n} from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\nimport { SwalPortalTarget, SwalPortalTargets } from './swal-portal-targets.service';\nimport { SwalPortalComponent } from './swal-portal.component';\nimport { SwalComponent } from './swal.component';\nimport { SweetAlert2LoaderService } from './sweetalert2-loader.service';\n\n/**\n * A structural directive that lets you use Angular templates inside of SweetAlerts.\n * There are different targetable zones provided by {@link SwalPortalTargets}: title, content, confirmButton, etc, but\n * you can also make your own target by implementing {@link SwalPortalTarget} and giving it to this directive.\n * The default target is the alert text content zone.\n *\n * Usage in your component's TypeScript (if you use another target than {@link SwalPortalTargets.content}):\n *\n *     @Component({ ... })\n *     export class MyComponent {\n *         public constructor(public readonly swalTargets: SwalPortalTargets) {\n *         }\n *     }\n *\n * Usage in the template:\n *\n *     <swal title=\"Fill the form\" (confirm)=\"confirmHandler()\">\n *         <!-- This form will be displayed as the alert main content\n *              Targets the alert's main content zone by default -->\n *         <form *swalPortal [formControl]=\"myForm\">\n *             ...\n *         </form>\n *\n *         <!-- This targets the confirm button's inner content\n *              Notice the usage of ng-container to avoid creating an useless DOM element inside the button -->\n *         <ng-container *swalPortal=\"swalTargets.confirmButton\">\n *              Send ({{ secondsLeft }} seconds left)\n *         </ng-container>\n *     <swal>\n */\n@Directive({\n    selector: '[swalPortal]'\n})\nexport class SwalPortalDirective implements OnInit, OnDestroy {\n    /**\n     * Takes a portal target or nothing (then it will target the text content zone by default).\n     *\n     * See the {@link SwalPortalTargets} service to see the available targets.\n     * See the class doc block for more informations.\n     */\n    @Input('swalPortal')\n    public target?: SwalPortalTarget;\n\n    /**\n     * Holds the component reference of the controlled SwalPortalComponent to destroy it when no longer needed.\n     */\n    private portalComponentRef?: ComponentRef<SwalPortalComponent>;\n\n    private readonly destroyed = new Subject<void>();\n\n    public constructor(\n        private readonly resolver: ComponentFactoryResolver,\n        private readonly injector: Injector,\n        private readonly app: ApplicationRef,\n        private readonly templateRef: TemplateRef<any>,\n        private readonly sweetAlert2Loader: SweetAlert2LoaderService,\n        private readonly swalTargets: SwalPortalTargets,\n        @Host() private readonly swalComponent: SwalComponent) {\n    }\n\n    /**\n     * Subscribes to the the SweetAlert appearance/disappearance events to create/destroy the SwalPortalComponent\n     * that will receive the consumer's template.\n     */\n    public ngOnInit(): void {\n        // Can't be set in a default property value, if the customer lets *swalPortal empty, the value we get is undef.\n        this.target = this.target || this.swalTargets.content;\n\n        //=> Apply the options provided by the target definition\n        void this.swalComponent.update(this.target.options);\n\n        //=> Subscribe to a few hooks frm the parent SwalComponent.\n        this.swalComponent.didRender.pipe(takeUntil(this.destroyed)).subscribe(this.didRenderHook.bind(this));\n        this.swalComponent.willOpen.pipe(takeUntil(this.destroyed)).subscribe(this.willOpenHook.bind(this));\n        this.swalComponent.didDestroy.pipe(takeUntil(this.destroyed)).subscribe(this.didDestroyHook.bind(this));\n    }\n\n    /**\n     * Signal any {@link destroyed} consumer that this is over, so they can unsubscribe from the\n     * parent SwalComponent events.\n     */\n    public ngOnDestroy(): void {\n        this.destroyed.next();\n    }\n\n    /**\n     * This didRender hook runs 1..n times (per modal instance), just before the modal is shown (and also before the\n     * {@link willOpenHook}), or after Swal.update() is called.\n     * This is a good place to render, or re-render, our portal contents.\n     */\n    private async didRenderHook(): Promise<void> {\n        //=> Ensure the portal component is created\n        if (!this.portalComponentRef) {\n            this.portalComponentRef = this.createPortalComponent();\n        }\n\n        //=> SweetAlert2 created the modal or just erased all of our content, so we need to install/reinstall it.\n        // Swal.update() is synchronous, this observable too, and mountComponentOnTarget too (the promise inside\n        // this function is already resolved at this point), so the whole process of re-rendering and re-mounting\n        // the portal component is fully synchronous, causing no blinks in the modal contents.\n        const swal = await this.sweetAlert2Loader.swal;\n\n        //=> Find target element\n        const targetEl = this.target!.element(swal);\n        if (!targetEl) return;\n\n        //=> Replace target's contents with our component\n        // https://jsperf.com/innerhtml-vs-removechild/15\n        while (targetEl.firstChild) {\n            targetEl.removeChild(targetEl.firstChild);\n        }\n\n        targetEl.appendChild(this.portalComponentRef.location.nativeElement);\n    }\n\n    /**\n     * This willOpen hook runs once (per modal instance), just before the modal is shown on the screen.\n     * This is a good place to declare our detached view to the Angular app.\n     */\n    private willOpenHook(): void {\n        if (!this.portalComponentRef) return;\n\n        //=> Make the Angular app aware of that detached view so rendering and change detection can happen\n        this.app.attachView(this.portalComponentRef.hostView);\n    }\n\n    /**\n     * This didDestroy hook runs once (per modal instance), just after the modal closing animation terminated.\n     * This is a good place to detach and destroy our content, that is not visible anymore.\n     */\n    private didDestroyHook(): void {\n        if (!this.portalComponentRef) return;\n\n        //=> Detach the portal component from the app and destroy it\n        this.app.detachView(this.portalComponentRef.hostView);\n        this.portalComponentRef.destroy();\n        this.portalComponentRef = void 0;\n    }\n\n    /**\n     * Creates the {@link SwalPortalComponent} and gives it the customer's template ref.\n     */\n    private createPortalComponent(): ComponentRef<SwalPortalComponent> {\n        //=> Create the SwalPortalComponent that will hold our content\n        const factory = this.resolver.resolveComponentFactory(SwalPortalComponent);\n\n        // Yes, we do not use the third argument that would directly use the target as the component's view\n        // (unfortunately, because that would give a cleaner DOM and would avoid dirty and direct DOM manipulations)\n        // That's because we want to keep our component safe from SweetAlert2's operations on the DOM, and to be\n        // able to restore it at any moment, ie. after the modal has been re-rendered.\n        const componentRef = factory.create(this.injector, []);\n\n        //=> Apply the consumer's template on the component\n        componentRef.instance.template = this.templateRef;\n\n        return componentRef;\n    }\n}\n","import { CommonModule } from '@angular/common';\nimport { ModuleWithProviders, NgModule } from '@angular/core';\nimport { dismissOnDestroyToken, fireOnInitToken, swalProviderToken } from './di';\nimport { SwalPortalComponent } from './swal-portal.component';\nimport { SwalPortalDirective } from './swal-portal.directive';\nimport { SwalComponent } from './swal.component';\nimport { SwalDirective } from './swal.directive';\nimport { SwalProvider, SweetAlert2LoaderService } from './sweetalert2-loader.service';\n\nexport interface Sweetalert2ModuleConfig {\n    provideSwal?: SwalProvider;\n    fireOnInit?: boolean;\n    dismissOnDestroy?: boolean;\n}\n\nexport function provideDefaultSwal() {\n    return import('sweetalert2');\n}\n\n@NgModule({\n    declarations: [\n        SwalDirective, SwalComponent, SwalPortalDirective, SwalPortalComponent\n    ],\n    imports: [\n        CommonModule\n    ],\n    exports: [\n        SwalComponent, SwalPortalDirective, SwalDirective\n    ]\n})\nexport class SweetAlert2Module {\n    public static forRoot(options: Sweetalert2ModuleConfig = {}): ModuleWithProviders<SweetAlert2Module> {\n        return {\n            ngModule: SweetAlert2Module,\n            providers: [\n                SweetAlert2LoaderService,\n                { provide: swalProviderToken, useValue: options.provideSwal || provideDefaultSwal },\n                { provide: fireOnInitToken, useValue: options.fireOnInit || false },\n                { provide: dismissOnDestroyToken, useValue: options.dismissOnDestroy || true }\n            ]\n        };\n    }\n\n    public static forChild(options: Sweetalert2ModuleConfig = {}): ModuleWithProviders<SweetAlert2Module> {\n        return {\n            ngModule: SweetAlert2Module,\n            providers: [\n                ...options.provideSwal ? [\n                    SweetAlert2LoaderService,\n                    { provide: swalProviderToken, useValue: options.provideSwal }\n                ] : [],\n                ...options.fireOnInit !== undefined ? [\n                    { provide: fireOnInitToken, useValue: options.fireOnInit }\n                ] : [],\n                ...options.dismissOnDestroy !== undefined ? [\n                    { provide: dismissOnDestroyToken, useValue: options.dismissOnDestroy }\n                ] : []\n            ]\n        };\n    }\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],"mappings":";;;;;;;;;ICWaA,EAAA,CAAAC,kBAAA,EGFC;EAAA;AAAA;AJNP,MAAMC,iBAAiB,GAAG,IAAIC,cAAc,CAAc,2CAA2C,CAAC;AAEtG,MAAMC,eAAe,GAAG,IAAID,cAAc,CAAU,yCAAyC,CAAC;AAE9F,MAAME,qBAAqB,GAAG,IAAIF,cAAc,CAAU,+CAA+C,CAAC;MCIpGG,wBAAwB;EAChBC,YAAY;EAErBC,gBAAgB;;EAGxBC,YAA8CF,YAAiB;IAC3D,IAAI,CAACA,YAAY,GAAGA,YAAY;;EAGpC,IAAWG,IAAIA,CAAA;IACX,IAAI,CAAC,IAAI,CAACF,gBAAgB,EAAE;MACxB,IAAI,CAACG,wBAAwB,EAAE;IAClC;IAED,OAAO,IAAI,CAACH,gBAAiB;;EAG1BG,wBAAwBA,CAAA;IAC3B,IAAI,IAAI,CAACH,gBAAgB,EAAE;IAE3B,MAAMI,UAAU,GAAGC,QAAQ,CAAC,IAAI,CAACN,YAAY,CAAC,GACxC,IAAI,CAACA,YAAY,EAAE,GACnBO,OAAO,CAACC,OAAO,CAAC,IAAI,CAACR,YAAY,CAAC;IAExC,IAAI,CAACC,gBAAgB,GAAGI,UAAU,CAACI,IAAI,CAACC,KAAK,IAAIC,eAAe,CAACD,KAAK,CAAC,GAAGA,KAAK,GAAGA,KAAK,CAACE,OAAO,CAAC;IAEhG,SAASN,QAAQA,CAACI,KAAmB;MACjC,OAAO,OAAOA,KAAK,KAAK,UAAU,IAAKA,KAAa,CAACG,OAAO,KAAKC,SAAS;;IAG9E,SAASH,eAAeA,CAACD,KAAiB;MACtC,OAAO,OAAOA,KAAK,KAAK,UAAU;;;EAhCjC,OAAAK,IAAA,YAAAC,iCAAAC,CAAA;IAAA,YAAAA,CAAA,IAAAlB,wBAAwB,EAAxBN,EAAA,CAAAyB,QAAA,CAMkBvB,iBAAiB;EAAA;gCANnCF,EAAA,CAAA0B,kBAAA;IAAAC,KAAA,EAAArB,wBAAwB;IAAAsB,OAAA,EAAxBtB,wBAAwB,CAAAgB;EAAA;;;qDAAxBtB,EAAA,CAAA6B,iBAAA,CAAAvB,wBAAwB;UADpCwB;;;;;cAOuBC,MAAM;eAAC7B,iBAAiB;;;;;;ACRhD;;;;;;;;;;;;;;;;;;;AAmBG;MAMU8B,aAAa;EAmPDC,iBAAA;EACyBC,qBAAA;EACMC,2BAAA;EApPpCC,KAAK;EACLC,SAAS;EACTC,IAAI;EACJC,IAAI;EACJC,MAAM;EACNC,IAAI;EACJC,SAAS;EACTC,QAAQ;EACRC,QAAQ;EACRC,KAAK;EACLC,MAAM;EACNC,KAAK;EACLC,KAAK;EACLC,OAAO;EACPC,UAAU;EACVC,QAAQ;EACRC,IAAI;EACJC,SAAS;EACTC,SAAS;EACTC,WAAW;EACXC,KAAK;EACLC,gBAAgB;EAChBC,UAAU;EACVC,iBAAiB;EACjBC,cAAc;EACdC,aAAa;EACbC,sBAAsB;EACtBC,sBAAsB;EACtBC,iBAAiB;EACjBC,cAAc;EACdC,gBAAgB;EAChBC,iBAAiB;EACjBC,cAAc;EACdC,gBAAgB;EAChBC,kBAAkB;EAClBC,eAAe;EACfC,iBAAiB;EACjBC,sBAAsB;EACtBC,mBAAmB;EACnBC,qBAAqB;EACrBC,cAAc;EACdC,cAAc;EACdC,YAAY;EACZC,SAAS;EACTC,WAAW;EACXC,eAAe;EACfC,eAAe;EACfC,oBAAoB;EACpBC,UAAU;EACVC,mBAAmB;EACnBC,UAAU;EACVC,OAAO;EACPC,QAAQ;EACRC,UAAU;EACVC,WAAW;EACXC,QAAQ;EACRC,UAAU;EACVC,gBAAgB;EAChBC,UAAU;EACVC,YAAY;EACZC,aAAa;EACbC,eAAe;EACfC,cAAc;EACdC,sBAAsB;EACtBC,iBAAiB;EACjBC,aAAa;EACbC,mBAAmB;EACnBC,qBAAqB;EACrBC,gBAAgB;EAEhC;;;;;;;;;;AAUG;EACH,IACWC,WAAWA,CAACC,OAA0B;;IAE7CC,MAAM,CAACC,MAAM,CAAC,IAAI,EAAEF,OAAO,CAAC;;IAG5B,MAAMG,WAAW,GAAGF,MAAM,CAACG,IAAI,CAACJ,OAAO,CAAmC;IAC1EG,WAAW,CAACE,OAAO,CAAC,IAAI,CAACC,WAAW,CAAC;;EAGzC;;;;AAIG;EACH,IAAWP,WAAWA,CAAA;;;;IAIlB,OAAO,CAAC,GAAG,IAAI,CAACQ,YAAY,CAAC,CAACC,MAAM,CAChC,CAACC,GAAG,EAAEC,GAAG,MAAM;MAAE,GAAGD,GAAG;MAAE,CAACC,GAAG,GAAG,IAAI,CAACA,GAAiB;IAAC,CAAE,CAAC,EAC1D,EAAE,CAAC;;EAGX;;;;;;AAMG;EAEIC,cAAc;EAErB;;;AAGG;EAEIC,oBAAoB;EAE3B,IACWC,WAAWA,CAACC,OAAgB;IACnCA,OAAO,GAAG,IAAI,CAACC,IAAI,EAAE,GAAG,IAAI,CAACC,KAAK,EAAE;;EAGxC,IAAWH,WAAWA,CAAA;IAClB,OAAO,IAAI,CAACI,gBAAgB;;EAGhC;;AAEG;EAEaC,QAAQ,GAAG,IAAIC,YAAY,EAAwB;EAEnE;;AAEG;EAEaC,OAAO,GAAG,IAAID,YAAY,EAAuB;EAEjE;;;;;;AAMG;EAEaE,SAAS,GAAG,IAAIF,YAAY,EAAyB;EAErE;;;AAGG;EAEaG,SAAS,GAAG,IAAIH,YAAY,EAAyB;EAErE;;;AAGG;EAEaI,QAAQ,GAAG,IAAIJ,YAAY,EAAQ;EAEnD;;;;;AAKG;EAEaK,UAAU,GAAG,IAAIL,YAAY,EAAQ;EAErD;;;;;;;;;;;;;AAaG;EAEaM,OAAO,GAAG,IAAIN,YAAY,EAAO;EAEjD;;;;;;;;;;;AAWG;EAEaO,IAAI,GAAG,IAAIP,YAAY,EAAQ;EAE/C;;;;;;;;;;;;AAYG;EAEaQ,OAAO,GAAG,IAAIR,YAAY,EAAkC;EAE5E;;;AAGG;EACcZ,YAAY,GAAG,IAAIqB,GAAG,EAA2B;EAElE;;;AAGG;EACctB,WAAW,GAAG,IAAI,CAACC,YAAY,CAACsB,GAAG,CAACC,IAAI,CAAC,IAAI,CAACvB,YAAY,CAAC;EAE5E;;AAEG;EACKU,gBAAgB,GAAG,KAAK;EAEhClH,YACqBwB,iBAA2C,EAClBC,qBAA8B,EACxBC,2BAAoC;IAFnE,IAAiB,CAAAF,iBAAA,GAAjBA,iBAAiB;IACQ,IAAqB,CAAAC,qBAAA,GAArBA,qBAAqB;IACf,IAA2B,CAAAC,2BAAA,GAA3BA,2BAA2B;;EAG/E;;;;;AAKG;EACIsG,QAAQA,CAAA;;IAEX,IAAI,CAACxG,iBAAiB,CAACtB,wBAAwB,EAAE;;EAGrD;;;AAGG;EACI+H,eAAeA,CAAA;IAClB,MAAMC,UAAU,GAAG,IAAI,CAACtB,cAAc,KAAKhG,SAAS,GAC9C,IAAI,CAACa,qBAAqB,GAC1B,IAAI,CAACmF,cAAc;IAEzBsB,UAAU,IAAI,IAAI,CAAClB,IAAI,EAAE;;EAG7B;;;AAGG;EACImB,WAAWA,CAACC,OAAsB;;;IAGrClC,MAAM,CAACG,IAAI,CAAC+B,OAAO;;KAEdC,MAAM,CAAE1B,GAAG,IAAqC,CAACA,GAAG,CAAC2B,UAAU,CAAC,MAAM,CAAC,CAAC,CACxEhC,OAAO,CAAC,IAAI,CAACC,WAAW,CAAC;;IAG9B,KAAK,IAAI,CAACgC,MAAM,EAAE;;EAGtB;;;AAGG;EACIC,WAAWA,CAAA;;IAEd,MAAMC,gBAAgB,GAAG,IAAI,CAAC5B,oBAAoB,KAAKjG,SAAS,GAC1D,IAAI,CAACc,2BAA2B,GAChC,IAAI,CAACmF,oBAAoB;IAE/B4B,gBAAgB,IAAI,IAAI,CAACxB,KAAK,EAAE;;EAGpC;;;;;AAKG;EACUD,IAAIA,CAAA;IAAA,IAAA0B,KAAA;IAAA,OAAAC,iBAAA;MACb,MAAM1I,IAAI,SAASyI,KAAI,CAAClH,iBAAiB,CAACvB,IAAI;MAE9C,MAAM2I,WAAW,GAAGF,KAAI,CAAC1C,WAAW;;MAGpC,MAAMC,OAAO,GAAsB;;QAE/B,GAAG2C,WAAW;;QAGdzB,QAAQ,EAAE0B,WAAW,CAACD,WAAW,CAACzB,QAAQ,EAAG2B,YAAY,IAAI;UACzDJ,KAAI,CAACvB,QAAQ,CAAC4B,IAAI,CAAC;YAAED;UAAY,CAAE,CAAC;QACxC,CAAC,CAAC;QACFzB,OAAO,EAAEwB,WAAW,CAACD,WAAW,CAACvB,OAAO,EAAGyB,YAAY,IAAI;UACvDJ,KAAI,CAACxB,gBAAgB,GAAG,IAAI;UAC5BwB,KAAI,CAACrB,OAAO,CAAC0B,IAAI,CAAC;YAAED;UAAY,CAAE,CAAC;QACvC,CAAC,CAAC;QACFxB,SAAS,EAAEuB,WAAW,CAACD,WAAW,CAACtB,SAAS,EAAGwB,YAAY,IAAI;UAC3DJ,KAAI,CAACpB,SAAS,CAACyB,IAAI,CAAC;YAAED;UAAY,CAAE,CAAC;QACzC,CAAC,CAAC;QACFvB,SAAS,EAAEsB,WAAW,CAACD,WAAW,CAACrB,SAAS,EAAGuB,YAAY,IAAI;UAC3DJ,KAAI,CAACxB,gBAAgB,GAAG,KAAK;UAC7BwB,KAAI,CAACnB,SAAS,CAACwB,IAAI,CAAC;YAAED;UAAY,CAAE,CAAC;QACzC,CAAC,CAAC;QACFtB,QAAQ,EAAEqB,WAAW,CAACD,WAAW,CAACpB,QAAQ,EAAE,MAAK;UAC7CkB,KAAI,CAAClB,QAAQ,CAACuB,IAAI,EAAE;QACxB,CAAC,CAAC;QACFtB,UAAU,EAAEoB,WAAW,CAACD,WAAW,CAACnB,UAAU,EAAE,MAAK;UACjDiB,KAAI,CAACjB,UAAU,CAACsB,IAAI,EAAE;QAC1B,CAAC;OACJ;;MAGD,MAAMC,MAAM,SAAS/I,IAAI,CAAC+G,IAAI,CAACf,OAAO,CAAC;;MAGvC,QAAQ,IAAI;QACR,KAAK+C,MAAM,CAACC,WAAW;UAAEP,KAAI,CAAChB,OAAO,CAACqB,IAAI,CAACC,MAAM,CAACxI,KAAK,CAAC;UAAE;QAC1D,KAAKwI,MAAM,CAACE,QAAQ;UAAER,KAAI,CAACf,IAAI,CAACoB,IAAI,EAAE;UAAE;QACxC,KAAKC,MAAM,CAACG,WAAW;UAAET,KAAI,CAACd,OAAO,CAACmB,IAAI,CAACC,MAAM,CAACpB,OAAO,CAAC;UAAE;MAC/D;MAED,OAAOoB,MAAM;MAEb,SAASH,WAAWA,CAChBO,QAAuB,EACvBC,OAAU;QAEV,OAAO,CAAC,GAAGC,IAAI,MAAMD,OAAO,CAAC,GAAGC,IAAI,CAAC,EAAEF,QAAQ,GAAG,GAAGE,IAAI,CAAC,CAAC;;IAC9D;;EAGL;;;;;;AAMG;EACUrC,KAAKA,CAAC+B,MAAyB;IAAA,IAAAO,MAAA;IAAA,OAAAZ,iBAAA;MACxC,IAAI,CAACY,MAAI,CAACrC,gBAAgB,EAAE;MAE5B,MAAMjH,IAAI,SAASsJ,MAAI,CAAC/H,iBAAiB,CAACvB,IAAI;MAC9CA,IAAI,CAACgH,KAAK,CAAC+B,MAAM,CAAC;IAAC;;EAGvB;;;;;;;AAOG;EACUT,MAAMA,CAACtC,OAAgE;IAAA,IAAAuD,MAAA;IAAA,OAAAb,iBAAA;MAChF,IAAI1C,OAAO,EAAE;QACTuD,MAAI,CAACxD,WAAW,GAAGC,OAAO;MAC7B;MAED,IAAI,CAACuD,MAAI,CAACtC,gBAAgB,EAAE;MAE5B,MAAMjH,IAAI,SAASuJ,MAAI,CAAChI,iBAAiB,CAACvB,IAAI;MAE9C,MAAMwJ,UAAU,GAAGD,MAAI,CAACxD,WAAW;MAEnC,MAAM0D,gBAAgB,GAAGxD,MAAM,CAACG,IAAI,CAACoD,UAAU,CAAC,CAC3CpB,MAAM,CAACpI,IAAI,CAAC0J,oBAAoB,CAAC,CACjClD,MAAM,CACH,CAACC,GAAG,EAAEC,GAAG,MAAM;QAAE,GAAGD,GAAG;QAAE,CAACC,GAAG,GAAG8C,UAAU,CAAC9C,GAAG;MAAC,CAAE,CAAC,EAClD,EAAE,CAAC;MAEX1G,IAAI,CAACsI,MAAM,CAACmB,gBAAgB,CAAC;IAAC;;;qBA9YzBnI,aAAa,EDvBbhC,EAAA,CAAAqK,iBAAA,CCuBa/J,wBAAA,GDvBbN,EAAA,CAAAqK,iBAAA,CC2QGjK,eAAe,GD3QlBJ,EAAA,CAAAqK,iBAAA,CC4QGhK,qBAAqB;EAAA;EArPxB,OAAAiK,IAAA,kBDvBAtK,EAAA,CAAAuK,iBAAA;IAAAC,IAAA,ECuBAxI,aAAa;IAAAyI,SAAA;IAAAC,MAAA;MAAAtI,KAAA;MAAAC,SAAA;MAAAC,IAAA;MAAAC,IAAA;MAAAC,MAAA;MAAAC,IAAA;MAAAC,SAAA;MAAAC,QAAA;MAAAC,QAAA;MAAAC,KAAA;MAAAC,MAAA;MAAAC,KAAA;MAAAC,KAAA;MAAAC,OAAA;MAAAC,UAAA;MAAAC,QAAA;MAAAC,IAAA;MAAAC,SAAA;MAAAC,SAAA;MAAAC,WAAA;MAAAC,KAAA;MAAAC,gBAAA;MAAAC,UAAA;MAAAC,iBAAA;MAAAC,cAAA;MAAAC,aAAA;MAAAC,sBAAA;MAAAC,sBAAA;MAAAC,iBAAA;MAAAC,cAAA;MAAAC,gBAAA;MAAAC,iBAAA;MAAAC,cAAA;MAAAC,gBAAA;MAAAC,kBAAA;MAAAC,eAAA;MAAAC,iBAAA;MAAAC,sBAAA;MAAAC,mBAAA;MAAAC,qBAAA;MAAAC,cAAA;MAAAC,cAAA;MAAAC,YAAA;MAAAC,SAAA;MAAAC,WAAA;MAAAC,eAAA;MAAAC,eAAA;MAAAC,oBAAA;MAAAC,UAAA;MAAAC,mBAAA;MAAAC,UAAA;MAAAC,OAAA;MAAAC,QAAA;MAAAC,UAAA;MAAAC,WAAA;MAAAC,QAAA;MAAAC,UAAA;MAAAC,gBAAA;MAAAC,UAAA;MAAAC,YAAA;MAAAC,aAAA;MAAAC,eAAA;MAAAC,cAAA;MAAAC,sBAAA;MAAAC,iBAAA;MAAAC,aAAA;MAAAC,mBAAA;MAAAC,qBAAA;MAAAC,gBAAA;MAAAC,WAAA;MAAAY,cAAA;MAAAC,oBAAA;MAAAC,WAAA;IAAA;IAAAoD,OAAA;MAAA/C,QAAA;MAAAE,OAAA;MAAAC,SAAA;MAAAC,SAAA;MAAAC,QAAA;MAAAC,UAAA;MAAAC,OAAA;MAAAC,IAAA;MAAAC,OAAA;IAAA;IAAAuC,QAAA,GDvBb5K,EAAA,CAAA6K,oBAAA;IAAAC,KAAA;IAAAC,IAAA;IAAAC,QAAA,WAAAC,uBAAAC,EAAA,EAAAC,GAAA;IAAAC,aAAA;IAAAC,eAAA;EAAA;;;qDAAArL,EAAA,CAAA6B,iBAAA,CCuBAG,aAAa;UALzBsJ,SAAS;IAACvB,IAAA;MACPwB,QAAQ,EAAE,MAAM;MAChBP,QAAQ,EAAE,EAAE;MACZK,eAAe,EAAEG,uBAAuB,CAACC;IAC5C;;;;;;;cAqPQ1J,MAAM;eAAC3B,eAAe;;;;;cACtB2B,MAAM;eAAC1B,qBAAqB;;;;IApPjB+B,KAAK;YAApBsJ;;IACerJ,SAAS;YAAxBqJ;;IACepJ,IAAI;YAAnBoJ;;IACenJ,IAAI;YAAnBmJ;;IACelJ,MAAM;YAArBkJ;;IACejJ,IAAI;YAAnBiJ;;IACehJ,SAAS;YAAxBgJ;;IACe/I,QAAQ;YAAvB+I;;IACe9I,QAAQ;YAAvB8I;;IACe7I,KAAK;YAApB6I;;IACe5I,MAAM;YAArB4I;;IACe3I,KAAK;YAApB2I;;IACe1I,KAAK;YAApB0I;;IACezI,OAAO;YAAtByI;;IACexI,UAAU;YAAzBwI;;IACevI,QAAQ;YAAvBuI;;IACetI,IAAI;YAAnBsI;;IACerI,SAAS;YAAxBqI;;IACepI,SAAS;YAAxBoI;;IACenI,WAAW;YAA1BmI;;IACelI,KAAK;YAApBkI;;IACejI,gBAAgB;YAA/BiI;;IACehI,UAAU;YAAzBgI;;IACe/H,iBAAiB;YAAhC+H;;IACe9H,cAAc;YAA7B8H;;IACe7H,aAAa;YAA5B6H;;IACe5H,sBAAsB;YAArC4H;;IACe3H,sBAAsB;YAArC2H;;IACe1H,iBAAiB;YAAhC0H;;IACezH,cAAc;YAA7ByH;;IACexH,gBAAgB;YAA/BwH;;IACevH,iBAAiB;YAAhCuH;;IACetH,cAAc;YAA7BsH;;IACerH,gBAAgB;YAA/BqH;;IACepH,kBAAkB;YAAjCoH;;IACenH,eAAe;YAA9BmH;;IACelH,iBAAiB;YAAhCkH;;IACejH,sBAAsB;YAArCiH;;IACehH,mBAAmB;YAAlCgH;;IACe/G,qBAAqB;YAApC+G;;IACe9G,cAAc;YAA7B8G;;IACe7G,cAAc;YAA7B6G;;IACe5G,YAAY;YAA3B4G;;IACe3G,SAAS;YAAxB2G;;IACe1G,WAAW;YAA1B0G;;IACezG,eAAe;YAA9ByG;;IACexG,eAAe;YAA9BwG;;IACevG,oBAAoB;YAAnCuG;;IACetG,UAAU;YAAzBsG;;IACerG,mBAAmB;YAAlCqG;;IACepG,UAAU;YAAzBoG;;IACenG,OAAO;YAAtBmG;;IACelG,QAAQ;YAAvBkG;;IACejG,UAAU;YAAzBiG;;IACehG,WAAW;YAA1BgG;;IACe/F,QAAQ;YAAvB+F;;IACe9F,UAAU;YAAzB8F;;IACe7F,gBAAgB;YAA/B6F;;IACe5F,UAAU;YAAzB4F;;IACe3F,YAAY;YAA3B2F;;IACe1F,aAAa;YAA5B0F;;IACezF,eAAe;YAA9ByF;;IACexF,cAAc;YAA7BwF;;IACevF,sBAAsB;YAArCuF;;IACetF,iBAAiB;YAAhCsF;;IACerF,aAAa;YAA5BqF;;IACepF,mBAAmB;YAAlCoF;;IACenF,qBAAqB;YAApCmF;;IACelF,gBAAgB;YAA/BkF;;IAcUjF,WAAW;YADrBiF;;IAgCMrE,cAAc;YADpBqE;;IAQMpE,oBAAoB;YAD1BoE;;IAIUnE,WAAW;YADrBmE;;IAae9D,QAAQ;YADvB+D;;IAOe7D,OAAO;YADtB6D;;IAWe5D,SAAS;YADxB4D;;IAQe3D,SAAS;YADxB2D;;IAQe1D,QAAQ;YADvB0D;;IAUezD,UAAU;YADzByD;;IAkBexD,OAAO;YADtBwD;;IAgBevD,IAAI;YADnBuD;;IAiBetD,OAAO;YADtBsD;;;;;ACvPL;;;;;;;;;;;;;;;AAeG;MAIUC,aAAa;EAyFDC,gBAAA;EACAC,QAAA;EAzFrB;;;AAGG;EACH,IACWpL,IAAIA,CAACgG,OAAmE;IAC/E,IAAIA,OAAO,YAAY1E,aAAa,EAAE;MAClC,IAAI,CAAC+J,YAAY,GAAGrF,OAAO;IAC9B,OAAM,IAAIsF,cAAc,CAACtF,OAAO,CAAC,EAAE;MAChC,IAAI,CAACD,WAAW,GAAG,EAAE;MACrB,CAAC,IAAI,CAACA,WAAW,CAACrE,KAAK,EAAE,IAAI,CAACqE,WAAW,CAACnE,IAAI,EAAE,IAAI,CAACmE,WAAW,CAAChE,IAAI,CAAC,GAAGiE,OAAO;IACnF,OAAM;MACH,IAAI,CAACD,WAAW,GAAGC,OAAO;IAC7B;IAED,SAASsF,cAAcA,CAAC/K,KAAU;MAC9B,OAAOgL,KAAK,CAACC,OAAO,CAACxF,OAAO,CAAC;;;EAIrC;;;;;;;;;;;;;AAaG;EAEayB,OAAO,GAAG,IAAIN,YAAY,EAAO;EAEjD;;;;;;;;;;;AAWG;EAEaO,IAAI,GAAG,IAAIP,YAAY,EAAQ;EAE/C;;;;;;;;;;;;AAYG;EAEaQ,OAAO,GAAG,IAAIR,YAAY,EAAkC;EAE5E;;;;AAIG;EACKsE,OAAO;EAEf;;;AAGG;EACKJ,YAAY;EAEpB;;;AAGG;EACKtF,WAAW;EAEnBhG,WACqBA,CAAAoL,gBAAkC,EAClCC,QAAkC;IADlC,IAAgB,CAAAD,gBAAA,GAAhBA,gBAAgB;IAChB,IAAQ,CAAAC,QAAA,GAARA,QAAQ;;EAG7B;;;;AAIG;EACIrD,QAAQA,CAAA;IACX,IAAI,CAAC,IAAI,CAACsD,YAAY,EAAE;MACpB,MAAMnK,OAAO,GAAG,IAAI,CAACkK,QAAQ,CAACM,uBAAuB,CAACpK,aAAa,CAAC;MAEpE,IAAI,CAACmK,OAAO,GAAG,IAAI,CAACN,gBAAgB,CAACQ,eAAe,CAACzK,OAAO,CAAC;MAC7D,IAAI,CAACmK,YAAY,GAAG,IAAI,CAACI,OAAO,CAACG,QAAQ;IAC5C;;EAGL;;;AAGG;EACIrD,WAAWA,CAAA;IACd,IAAI,IAAI,CAACkD,OAAO,EAAE;MACd,IAAI,CAACA,OAAO,CAACI,OAAO,EAAE;IACzB;;EAGL;;;;AAIG;EAEIC,OAAOA,CAACC,KAAiB;IAC5BA,KAAK,CAACC,cAAc,EAAE;IACtBD,KAAK,CAACE,wBAAwB,EAAE;IAChCF,KAAK,CAACG,eAAe,EAAE;IAEvB,IAAI,CAAC,IAAI,CAACb,YAAY,EAAE;IAExB,IAAI,IAAI,CAACtF,WAAW,EAAE;MAClB,IAAI,CAACsF,YAAY,CAACtF,WAAW,GAAG,IAAI,CAACA,WAAW;IACnD;IAED,MAAMoG,UAAU,GAAG,IAAIC,OAAO,EAAQ;IAEtC,IAAI,CAACf,YAAY,CAAC5D,OAAO,CAAC4E,YAAY,EAAE,CAACC,IAAI,CAACC,SAAS,CAACJ,UAAU,CAAC,CAAC,CAACK,SAAS,CAACC,CAAC,IAAI,IAAI,CAAChF,OAAO,CAACqB,IAAI,CAAC2D,CAAC,CAAC,CAAC;IACzG,IAAI,CAACpB,YAAY,CAAC3D,IAAI,CAAC2E,YAAY,EAAE,CAACC,IAAI,CAACC,SAAS,CAACJ,UAAU,CAAC,CAAC,CAACK,SAAS,CAACC,CAAC,IAAI,IAAI,CAAC/E,IAAI,CAACoB,IAAI,CAAC2D,CAAC,CAAC,CAAC;IACnG,IAAI,CAACpB,YAAY,CAAC1D,OAAO,CAAC0E,YAAY,EAAE,CAACC,IAAI,CAACC,SAAS,CAACJ,UAAU,CAAC,CAAC,CAACK,SAAS,CAACC,CAAC,IAAI,IAAI,CAAC9E,OAAO,CAACmB,IAAI,CAAC2D,CAAC,CAAC,CAAC;IAEzG,IAAI,CAACpB,YAAY,CAACtE,IAAI,EAAE,CAACzG,IAAI,CAAC,MAAM6L,UAAU,CAACO,IAAI,EAAE,CAAC;;;qBA5IjDxB,aAAa,EFjBb5L,EAAA,CAAAqK,iBAAA,CEiBarK,EAAA,CAAAqN,gBAAA,GFjBbrN,EAAA,CAAAqK,iBAAA,CEiBarK,EAAA,CAAAsN,wBAAA;EAAA;+BFjBbtN,EAAA,CAAAuN,iBAAA;IAAA/C,IAAA,EEiBAoB,aAAa;IAAAnB,SAAA;IAAA+C,YAAA,WAAAC,2BAAAvC,EAAA,EAAAC,GAAA;MAAA,IAAAD,EAAA;QFjBblL,EAAA,CAAA0N,UAAA,mBAAAC,uCAAAC,MAAA;UAAA,OEiBAzC,GAAA,CAAAqB,OAAA,CAAAoB,MAAa;QAAA;MAAA;IAAA;IAAAlD,MAAA;MAAAhK,IAAA;IAAA;IAAAiK,OAAA;MAAAxC,OAAA;MAAAC,IAAA;MAAAC,OAAA;IAAA;EAAA;;;qDFjBbrI,EAAA,CAAA6B,iBAAA,CEiBA+J,aAAa;UAHzBiC,SAAS;IAAC9D,IAAA;MACPwB,QAAQ,EAAE;IACb;;;;;;;;IAOc7K,IAAI;YADdgL;;IA+BevD,OAAO;YADtBwD;;IAgBevD,IAAI;YADnBuD;;IAiBetD,OAAO;YADtBsD;;IAyDMa,OAAO;YADbsB,YAAY;aAAC,OAAO,EAAE,CAAC,QAAQ,CAAC;;;;;ACpJrC;;;;AAIG;MAMUC,mBAAmB;EAErB/C,QAAQ,GAA4B,IAAI;;qBAFtC+C,mBAAmB;EAAA;EAAnB,OAAAzD,IAAA,kBHDAtK,EAAA,CAAAuK,iBAAA;IAAAC,IAAA,EGCAuD,mBAAmB;IAAAtD,SAAA;IAAAC,MAAA;MAAAM,QAAA;IAAA;IAAAF,KAAA;IAAAC,IAAA;IAAAiD,MAAA;IAAAhD,QAAA,WAAAiD,6BAAA/C,EAAA,EAAAC,GAAA;MAAA,IAAAD,EAAA;QHDnBlL,EAAA,CAAAkO,UAAA,IAAAC,2CAAA,yBGFC;MAAA;MAAA,IAAAjD,EAAA;QHEDlL,EAAA,CAAAoO,UAAA,qBAAAjD,GAAA,CAAAH,QGFC;MAAA;IAAA;IAAAqD,YAAA,GAA4DC,EAAA,CAAAC,gBAAA;IAAAnD,aAAA;IAAAC,eAAA;EAAA;;;qDHE7DrL,EAAA,CAAA6B,iBAAA,CGCAkM,mBAAmB;UAL/BzC,SAAS;IAACvB,IAAA;MACPwB,QAAQ,EAAE,aAAa;MACvBP,QAAQ,EAAE,4DAA4D;MACtEK,eAAe,EAAEG,uBAAuB,CAACC;IAC5C;;IAGUT,QAAQ;YADdU;;;;;ACLL;;;;AAIG;MAEU8C,iBAAiB;EAC1B;;AAEG;EACaC,WAAW,GAAqB;IAC5CC,OAAO,EAAEhO,IAAI,IAAIA,IAAI,CAACiO,cAAc,EAAE;IACtCjI,OAAO,EAAE;MAAEzB,eAAe,EAAE;IAAI;GACnC;EAED;;AAEG;EACa7C,KAAK,GAAqB;IACtCsM,OAAO,EAAEhO,IAAI,IAAIA,IAAI,CAACkO,QAAQ,EAAE;;IAEhClI,OAAO,EAAE;MAAEtE,KAAK,EAAE;IAAG;GACxB;EAED;;;AAGG;EACayM,OAAO,GAAqB;IACxCH,OAAO,EAAEhO,IAAI,IAAIA,IAAI,CAACoO,gBAAgB,EAAE;;IAExCpI,OAAO,EAAE;MAAEpE,IAAI,EAAE;IAAG;GACvB;EAED;;;;;;AAMG;EACayM,OAAO,GAAqB;IACxCL,OAAO,EAAEhO,IAAI,IAAIA,IAAI,CAACsO,UAAU,EAAE;;IAElCtI,OAAO,EAAE;MAAE1C,iBAAiB,EAAE;IAAI;GACrC;EAED;;AAEG;EACaiL,aAAa,GAAqB;IAC9CP,OAAO,EAAEhO,IAAI,IAAIA,IAAI,CAACwO,gBAAgB,EAAE;IACxCxI,OAAO,EAAE;MAAE1C,iBAAiB,EAAE;IAAI;GACrC;EAED;;AAEG;EACamL,UAAU,GAAqB;IAC3CT,OAAO,EAAEhO,IAAI,IAAIA,IAAI,CAAC0O,aAAa,EAAE;IACrC1I,OAAO,EAAE;MAAEzC,cAAc,EAAE;IAAI;GAClC;EAED;;AAEG;EACaoL,YAAY,GAAqB;IAC7CX,OAAO,EAAEhO,IAAI,IAAIA,IAAI,CAAC4O,eAAe,EAAE;IACvC5I,OAAO,EAAE;MAAExC,gBAAgB,EAAE;IAAI;GACpC;EAED;;AAEG;EACa1B,MAAM,GAAqB;IACvCkM,OAAO,EAAEhO,IAAI,IAAIA,IAAI,CAAC6O,SAAS,EAAE;;IAEjC7I,OAAO,EAAE;MAAElE,MAAM,EAAE;IAAG;GACzB;;qBAxEQgM,iBAAiB;EAAA;EAAjB,OAAAgB,KAAA,kBJHAxP,EAAA,CAAA0B,kBAAA;IAAAC,KAAA,EIGA6M,iBAAiB;IAAA5M,OAAA,EAAjB4M,iBAAiB,CAAAlN,IAAA;IAAAmO,UAAA,EADJ;EAAM;;;qDJFnBzP,EAAA,CAAA6B,iBAAA,CIGA2M,iBAAiB;UAD7B1M,UAAU;WAAC;MAAE2N,UAAU,EAAE;IAAM,CAAE;;;;ACFlC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BG;MAIUC,mBAAmB;EAkBP5D,QAAA;EACA6D,QAAA;EACAC,GAAA;EACAC,WAAA;EACA5N,iBAAA;EACA6N,WAAA;EACQC,aAAA;EAvB7B;;;;;AAKG;EAEIjN,MAAM;EAEb;;AAEG;EACKkN,kBAAkB;EAETC,SAAS,GAAG,IAAInD,OAAO,EAAQ;EAEhDrM,YACqBqL,QAAkC,EAClC6D,QAAkB,EAClBC,GAAmB,EACnBC,WAA6B,EAC7B5N,iBAA2C,EAC3C6N,WAA8B,EACtBC,aAA4B;IANpC,IAAQ,CAAAjE,QAAA,GAARA,QAAQ;IACR,IAAQ,CAAA6D,QAAA,GAARA,QAAQ;IACR,IAAG,CAAAC,GAAA,GAAHA,GAAG;IACH,IAAW,CAAAC,WAAA,GAAXA,WAAW;IACX,IAAiB,CAAA5N,iBAAA,GAAjBA,iBAAiB;IACjB,IAAW,CAAA6N,WAAA,GAAXA,WAAW;IACH,IAAa,CAAAC,aAAA,GAAbA,aAAa;;EAG1C;;;AAGG;EACItH,QAAQA,CAAA;;IAEX,IAAI,CAAC3F,MAAM,GAAG,IAAI,CAACA,MAAM,IAAI,IAAI,CAACgN,WAAW,CAACjB,OAAO;;IAGrD,KAAK,IAAI,CAACkB,aAAa,CAAC/G,MAAM,CAAC,IAAI,CAAClG,MAAM,CAAC4D,OAAO,CAAC;;IAGnD,IAAI,CAACqJ,aAAa,CAAChI,SAAS,CAACiF,IAAI,CAACC,SAAS,CAAC,IAAI,CAACgD,SAAS,CAAC,CAAC,CAAC/C,SAAS,CAAC,IAAI,CAACgD,aAAa,CAAC1H,IAAI,CAAC,IAAI,CAAC,CAAC;IACrG,IAAI,CAACuH,aAAa,CAACnI,QAAQ,CAACoF,IAAI,CAACC,SAAS,CAAC,IAAI,CAACgD,SAAS,CAAC,CAAC,CAAC/C,SAAS,CAAC,IAAI,CAACiD,YAAY,CAAC3H,IAAI,CAAC,IAAI,CAAC,CAAC;IACnG,IAAI,CAACuH,aAAa,CAAC7H,UAAU,CAAC8E,IAAI,CAACC,SAAS,CAAC,IAAI,CAACgD,SAAS,CAAC,CAAC,CAAC/C,SAAS,CAAC,IAAI,CAACkD,cAAc,CAAC5H,IAAI,CAAC,IAAI,CAAC,CAAC;;EAG3G;;;AAGG;EACIS,WAAWA,CAAA;IACd,IAAI,CAACgH,SAAS,CAAC7C,IAAI,EAAE;;EAGzB;;;;AAIG;EACW8C,aAAaA,CAAA;IAAA,IAAAG,MAAA;IAAA,OAAAjH,iBAAA;;MAEvB,IAAI,CAACiH,MAAI,CAACL,kBAAkB,EAAE;QAC1BK,MAAI,CAACL,kBAAkB,GAAGK,MAAI,CAACC,qBAAqB,EAAE;MACzD;;;;;MAMD,MAAM5P,IAAI,SAAS2P,MAAI,CAACpO,iBAAiB,CAACvB,IAAI;;MAG9C,MAAM6P,QAAQ,GAAGF,MAAI,CAACvN,MAAO,CAAC4L,OAAO,CAAChO,IAAI,CAAC;MAC3C,IAAI,CAAC6P,QAAQ,EAAE;;;MAIf,OAAOA,QAAQ,CAACC,UAAU,EAAE;QACxBD,QAAQ,CAACE,WAAW,CAACF,QAAQ,CAACC,UAAU,CAAC;MAC5C;MAEDD,QAAQ,CAACG,WAAW,CAACL,MAAI,CAACL,kBAAkB,CAACW,QAAQ,CAACC,aAAa,CAAC;IAAC;;EAGzE;;;AAGG;EACKT,YAAYA,CAAA;IAChB,IAAI,CAAC,IAAI,CAACH,kBAAkB,EAAE;;IAG9B,IAAI,CAACJ,GAAG,CAACiB,UAAU,CAAC,IAAI,CAACb,kBAAkB,CAACc,QAAQ,CAAC;;EAGzD;;;AAGG;EACKV,cAAcA,CAAA;IAClB,IAAI,CAAC,IAAI,CAACJ,kBAAkB,EAAE;;IAG9B,IAAI,CAACJ,GAAG,CAACmB,UAAU,CAAC,IAAI,CAACf,kBAAkB,CAACc,QAAQ,CAAC;IACrD,IAAI,CAACd,kBAAkB,CAACzD,OAAO,EAAE;IACjC,IAAI,CAACyD,kBAAkB,GAAG,KAAK,CAAC;;EAGpC;;AAEG;EACKM,qBAAqBA,CAAA;;IAEzB,MAAM1O,OAAO,GAAG,IAAI,CAACkK,QAAQ,CAACM,uBAAuB,CAAC2B,mBAAmB,CAAC;;;;;IAM1E,MAAMiD,YAAY,GAAGpP,OAAO,CAACqP,MAAM,CAAC,IAAI,CAACtB,QAAQ,EAAE,EAAE,CAAC;;IAGtDqB,YAAY,CAAC1E,QAAQ,CAACtB,QAAQ,GAAG,IAAI,CAAC6E,WAAW;IAEjD,OAAOmB,YAAY;;;qBA1HdtB,mBAAmB,ELjCnB1P,EAAA,CAAAqK,iBAAA,CKiCmBrK,EAAA,CAAAsN,wBAAA,GLjCnBtN,EAAA,CAAAqK,iBAAA,CKiCmBrK,EAAA,CAAAkR,QAAA,GLjCnBlR,EAAA,CAAAqK,iBAAA,CKiCmBrK,EAAA,CAAAmR,cAAA,GLjCnBnR,EAAA,CAAAqK,iBAAA,CKiCmBrK,EAAA,CAAAoR,WAAA,GLjCnBpR,EAAA,CAAAqK,iBAAA,CKiCmB/J,wBAAA,GLjCnBN,EAAA,CAAAqK,iBAAA,CKiCmBmE,iBAAA,GLjCnBxO,EAAA,CAAAqK,iBAAA,CKiCmBrI,aAAA;EAAA;+BLjCnBhC,EAAA,CAAAuN,iBAAA;IAAA/C,IAAA,EKiCAkF,mBAAmB;IAAAjF,SAAA;IAAAC,MAAA;MAAA5H,MAAA;IAAA;EAAA;;;qDLjCnB9C,EAAA,CAAA6B,iBAAA,CKiCA6N,mBAAmB;UAH/B7B,SAAS;IAAC9D,IAAA;MACPwB,QAAQ,EAAE;IACb;;;;;;;;;;;;;;;;;cAyBQ8F;;;;IAhBEvO,MAAM;YADZ4I,KAAK;aAAC,YAAY;;;;SCpCP4F,kBAAkBA,CAAA;EAC9B,OAAO,OAAO,aAAa,CAAC;AAChC;MAaaC,iBAAiB;EACnB,OAAOC,OAAOA,CAAC9K,OAAA,GAAmC,EAAE;IACvD,OAAO;MACH+K,QAAQ,EAAEF,iBAAiB;MAC3BG,SAAS,EAAE,CACPpR,wBAAwB,EACxB;QAAEqR,OAAO,EAAEzR,iBAAiB;QAAE0R,QAAQ,EAAElL,OAAO,CAACmL,WAAW,IAAIP;MAAkB,CAAE,EACnF;QAAEK,OAAO,EAAEvR,eAAe;QAAEwR,QAAQ,EAAElL,OAAO,CAACiC,UAAU,IAAI;MAAK,CAAE,EACnE;QAAEgJ,OAAO,EAAEtR,qBAAqB;QAAEuR,QAAQ,EAAElL,OAAO,CAACwC,gBAAgB,IAAI;MAAI,CAAE;KAErF;;EAGE,OAAO4I,QAAQA,CAACpL,OAAA,GAAmC,EAAE;IACxD,OAAO;MACH+K,QAAQ,EAAEF,iBAAiB;MAC3BG,SAAS,EAAE,CACP,IAAGhL,OAAO,CAACmL,WAAW,GAAG,CACrBvR,wBAAwB,EACxB;QAAEqR,OAAO,EAAEzR,iBAAiB;QAAE0R,QAAQ,EAAElL,OAAO,CAACmL;MAAW,CAAE,CAChE,GAAG,EAAE,GACN,IAAGnL,OAAO,CAACiC,UAAU,KAAKtH,SAAS,GAAG,CAClC;QAAEsQ,OAAO,EAAEvR,eAAe;QAAEwR,QAAQ,EAAElL,OAAO,CAACiC;MAAU,CAAE,CAC7D,GAAG,EAAE,GACN,IAAGjC,OAAO,CAACwC,gBAAgB,KAAK7H,SAAS,GAAG,CACxC;QAAEsQ,OAAO,EAAEtR,qBAAqB;QAAEuR,QAAQ,EAAElL,OAAO,CAACwC;MAAgB,CAAE,CACzE,GAAG,EAAE;KAEb;;;qBA5BIqI,iBAAiB;EAAA;EAAjB,OAAAQ,IAAA,kBNnBA/R,EAAA,CAAAgS,gBAAA;IAAAxH,IAAA,EMmBA+G;EAAiB;EAAjB,OAAAU,IAAA,kBNnBAjS,EAAA,CAAAkS,gBAAA;IAAAC,OAAA,GMaLC,YAAY;EAAA;;;qDNbPpS,EAAA,CAAA6B,iBAAA,CMmBA0P,iBAAiB;UAX7Bc,QAAQ;IAACtI,IAAA;MACNuI,YAAY,EAAE,CACV1G,aAAa,EAAE5J,aAAa,EAAE0N,mBAAmB,EAAE3B,mBAAmB,CACzE;MACDoE,OAAO,EAAE,CACLC,YAAY,CACf;MACDG,OAAO,EAAE,CACLvQ,aAAa,EAAE0N,mBAAmB,EAAE9D,aAAa;IAExD;;;;AC7BD;;AAEG"},"metadata":{},"sourceType":"module","externalDependencies":[]}